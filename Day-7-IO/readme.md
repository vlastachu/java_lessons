#java.io

Относительно сложная тема к которой я уже третий раз пытаюсь подступиться. Более менее хорошо и полно она описана в книге "Thinking in Java" глава 16. Кстати это предпоследняя глава - то есть Эккель решил оставить её на тот момент, когда читатель хорошо ознакомиться со всем остальным. В то же время с io вы сталкиваетесь уже на первом занятии, т.к. вашим програмам требуется взаимодействовать с внешним миром. 

(здесь ещё небольшое вступление)

#java.io.InputStream

*Иерархия классов java.io отсносящикся к InputStream, отдельно выделен класс не из java.io но всё равно наследующийся от InputStream (таких много, это просто единичный пример) и отдельно выделены классы-декораторы.*

![hierarchy](https://leto41g.storage.yandex.net/rdisk/ac650f6acc90924ea61c14fe61d84a1d/mpfs/oVuHhReuvOjokimgr1GANfWhO8BEmBlQ-DlTuBp7Dqx3wO_PPe7afTq5Tuf_uuixuK6xvoMAO3a9ghCBCH-QOA==?uid=0&filename=2014-10-26%2019-27-19%20%D0%A1%D0%BA%D1%80%D0%B8%D0%BD%D1%88%D0%BE%D1%82%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0.png&disposition=inline&hash=&limit=0&content_type=image%2Fpng&rtoken=78a3a5fa4002442bb4eec09a53f76ca9&rtimestamp=544d1801&force_default=no)

InputStream - абстрактный класс, предназначенный для ввода байтов из различных источников таких, как:

* Массив байтов - ByteArrayInputStream
* Строка - StringBufferInputStream
* файл - FileInputStream
* канал (pipe) - PipedInputStream предназначен для общения между 2мя потоками в вашей программе
* System.in - стандартный ввод (из консоли) имеет тип InputStream 
* сеть - множество классов из java.net реализуют java.io.InputStream например SocketInputStream

Вполне естественно удивление - зачем нужны вводы из массивов и строк? То есть ввод из внешнего мира вполне очевиден, но зачем вводить то что итак внутри программы? Дело в том, что классы из пакета `java.io` кроме того что вводят данные, также и предназначены для их обработки. То есть допустим вами была получена строка и вы хотите её распарсить - вы оборачиваете её в StringBufferInputStream и далее во всякие PushBackInputStream о которых речь пойдёт далее. 

Итак что мы имеем: есть абстрактный класс InputStream - к нему мы прибегнем в том случае, если получаем поток из вне (например параметр для функции). Если мы хотим прочитать внешние (или не внешние) данные то мы используем потомок InputStream. Потомка выбираем изходя из типа источника данных. Наиболее частый случай - файл:

```java
InputStream is = new FileInputStream("file_name"); // всего есть 3 конструктора для этого класс
```

Отбросим пока что тему обработки исключений (допустим все действия происходят в try в котором все нужные типы обрабатываются). Посмотрим какими мы располагаем методами в InputStream:

```java
public abstract int read() throws IOException;
public int read(byte[] buffer, int offset, int length) throws IOException;
public int read(byte[] buffer) throws IOException;
```
Ещё вам пригодится `close` и например `skip` может быть. Первый читает один байт из потока и возвращает от 0 до 255 если байт ыл считан, либо -1 если файл закончился, либо исключение. Второй метод немного автоматизирует эту операцию и записывает байты в массив `buffer` начиная с позиции offset и до length. Возвращает -1 если файл закончен. Третий метод это `read(buffer, 0, buffer.length)`. С ним уже более менее жить можно, хотя в коде мы не так часто манипулируем байтами. 


#java.io.OutputStream

OutputStream - предназначен для вывода.

Классы с  OutputStream в основном имеют аналог с InputStream. Здесь мы также можем выводить в файл, в канал, в массив байтов. В строку нельзя (можно но нет прямого класса), для этого скорее подойдёт Reader и Writer. 


#Reader и Writer

*Основной причиной появления иерархий классов Reader и Writer стала интернационализация. Старая библиотека ввода/вывода поддерживала только 8-битовые символы и зачастую неверно обращалась с 16-битовыми символами Юникода. Именно благодаря символам Юникода возможна интернационализация программ (простейший тип Java char (символ) также основан на Юникоде), поэтому новые классы отвечают за их правильное использование в операциях ввода/вывода. Вдобавок новые средства спроектированы так, что работают быстрее старых классов.*

Если вы собираетесь работать с файлом как с текстом (на первое время это более частая задача с которой вы будете встречаться), то должны воспользовать классами Reader и Writer. Хоть в их названиян не присутствует слова Stream - они работают по тому принципу. В комментариях стандартной библиотеки они также упомянаются как stream.

Что характерно эти два класса появились в Java 1.1. И до неё читать текст через InputStream считалось нормальным и с тех пор остались классы LineNumberInputStream и StreamTokenizer принимает InputStream. Но сейчас это считается плохой практикой классы методы и конструкторы помечены как `deprecated` (устаревшие). Если вам нужен построчный ввод\вывод то вы определенно работаете с потоком символов, а не байтов.

Возможна ситуация, когда библиотека возвращает вам InputStream, но вы желаете работать с данными как с текстом. Для этого случая есть два *адаптера*: **InputStreamReader** (InputStream -> Reader), также **OutputStreamWriter**.

