#ООП

##Предисловие

Java в отличии от многих других высоко-уровневых языков ограничивает программиста в плане выбора парадигмы для написания кода. Например лисп изначально создавался с поддержкой мета-программирования и код было принято писать в функциональном стиле. Но также нет никаких ограничений чтобы писать императивный код. И впоследствии было сделано много реализаций системы классов для Common Lisp благодаря чему можно писать и в ООП стиле. С одной стороны гибкость языка кажется замечательным свойством. Противоположность для гибкости - строгость. Строгость также замечательное свойства. Гибкие языки часто необходимы при решении задач, имеющих исследовательский характер. Таких которые раньше не решали. Изначально, когда CS только зарождалось таких задач было большинство и постепенно появлялись общие подходы, шаблоны. В наше время задач требующих исследований по-прежнему немало. Количественно их больше чем было раньше. Но процентно их гораздо меньше. То есть устраиваясь на работу от вас потребуются прикладные навыки как например работа с базой данных с UI и тп. 

В таких условиях от языка программирования требуется надежность, определенность поведения (документированность), и строгость в плане подхода к решению задачи. Хотя наверное основным фактором успеха джавы в своё время стала кроссплатформенность и то что у джавы на разных платформах код работает одинаково в отлчиии от С где нет никаких гарантий что инт останется интом (простой поверхностный пример). 

Ещё раз насчет строгости гибкости. Про perl говорят, что у него есть 10 решений для одной задачи. Это считается нормой что программист использует разные конструкции для похожих задач. В основном пытаясь достичь выразительности и лаконичности кода. Программируя на джава вы жертвуете лаконичностью, зато взглянув на код вашего сотрудника, насколько бы он не был убог или запутан вы скорее всего догадаетесь что к чему. Конечно всегда есть возможность сделать все сложнее. Просто джава не располагает для этого средствами.

##Мотивация

Вы уже можете запрограммировать что угодно, т.к. располагаете знаниями о базовых операторах и конструкциях языка (ветвление, циклы). Вы уже можете писать код лаконичнее без лишних повторов используя функции. Давая переменным и функциям хорошие выразительные названия вы можете писать самодокументируемый код. На этом занятии мы впервые ознакомимся с составными структурами данных (до этого мы использовали примитивы в своих программах ну и ещё массивы примитивов). Также мы предоставим методы для обработки структур данных. Ознакомимся с базовыми понятиями ООП: наследование инкапсуляция полиморфизм. 

##Объекты

Для начала попробуем взглянуть на объекты как пользователи (всмысле пользователь чужого кода), позже разработаем свои объекты.
Объект по своей сути - структура хранящаяся в памяти. У этой струтуры имеется доступ к её полям (некоторые поля скрыты из внешнего кода, но об этом позже). Чтобы выделить в памяти место под наш объект мы используем оператор `new` который кроме выделения памяти также вызывает конструктор (по своей сути - обычная функция, только вызывается единожды при создании объекта). Как вы уже могли заметить оператор `.` (точка) позволяет обращаться к полям объекта. Поля у объекта бывают двух видов - во-первых поле-значение (далее буду иметь ввиду именно его говоря "поле"), которое также относится к памяти (может быть примитивом или другим объектом, как переменная). Во-вторых поле-функция или метод. Простейший пример объекта:

```java
Object object = new Object();
//Здесь мы: 1. инициализируем область в памяти под объект класса Object.
//2. Вызываем конструктор без параметров.
//3. Присваиваем его новой переменной с типом Object и названием object.  
System.out.println(object.toString());
//обращаемся к методу toString() (на самом деле он бы и так вызвался если бы мы передали объект)
```
На деле нам редко придётся создавать объекты класса Object - он наиболее абстрактный класс и с ним мы ничего делать не можем.

Например возмём знакомый нам массив. Он также является объектом, но с некоторым синтаксическим сахаром. 

Синтаксический сахар с том что мы объявляем его с записью отличающейся от других объектов - `int a[17];` или например берем значения через `a[1]` заместо `a.get(1);`. Это очень даже удобно, просто самостоятельно мы не сможем сделать подобного поведения. Тем не менее у массива есть поведение похожее на обычный объект:

```java
int a[] = {1, 2, 3, 4, 5};
//массив хранит поле в котором указывается количество элементов - обратимся к нему:
System.out.println(a.length); // => 5 
//никаких особых методов у массива не определено кроме тех же что у Object
```

Раз уж зашла речь про организацию памяти, то необходимо рассказать как память организуется в машине (всмысле на компьютере). Зачастую языки программирования стараются как можно больше абстрагироваться от реального железа, которое производит вычислительные операции. Но по причинам производительности те или иные детали вылазят в наружу.

Итак вам уже должно быть известно что память бывает внутренняя (оператива) и внешняя (жесткий диск, сеть и тд). В программе мы имеем дело с внутренней памятью и иногда нам приходится обращаться к внешней (например ваши домашние задания зачастую будут читать input.txt и записывать результат в output.txt). Рассмотрим подробнее внутреннюю память:

1. Регистры. Самое быстрое хранилище, процессор производит вычислительные операции обращаясь к регистрам. Их в наших домашних компьютерах совсем немного и про работу с ними вам не обязательно знать (до тех пор пока у вас не начнется курс по ассемблеру). Из java у вас нет никакого доступа к регистрам.

2. Кеш. Очень быстрое хранилище. Не обязательно присутствует в процессоре. Представляет из себя часть сохраненной оперативной памяти и служит для более быстрой загрузки данных из оперативы в регистры. Вам будет полезно знать про работу кеша - с ним связано такое понятие как "локальность данных". Но видимо вы познакомитесь с ним также на курсе по ассемблеру или устройству эвм.

3. Стек.  Эта область хранения данных находится в общей оперативной памяти (RAM), но процессор предоставляет прямой доступ к ней с использованием указателя стека. Указатель стека перемещается вниз для выделения памяти или вверх для ее освобождения. То есть по скорости обращения к данным - стек таже оперативная память, но выделение и освобождение ничего не стоят. Компилятор обязан знать время жизни данных хранящихся в стеке. Ещё одно ограничение - размер стека. Вы могли с ним познакомиться во время работы с рекурсией. Из-за небольшого размера в стеке не хранятся большие объекты (например строки массивы). В стеке принято хранить все глобальные (статические) и локальные переменные. Если ваша переменная представляет собой примитив то в стек прямо кладётся значение (число) и компилятор производит операции напрямую с этим число зная его положение в стеке.

4. Куча. Пул памяти общего назначения (находится также в RAM), в котором размещаются все объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго просуществуют находящиеся там объекты. Таким образом, работа с кучей дает значительное преимущество в гибкости. Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти из кучи занимает больше времени, чем в стеке. 

5. Постоянная память. Значения констант часто встраиваются прямо в код программы, так как они неизменны. Иногда такие данные могут размещаться в постоянной памяти (ROM), если речь идет о «встроенных» системах.

Итак что происходит когда вы пишете new? В куче выделяется память размером с ваш объект. В объекте срабатывает конструктор - инициализируются поля объекта. После этого объект присваивается переменной - в стеке выделяется поле размером с указатель (на 64-битных ОС размер этого поля будет 64 бита = 8 байт) и этот указатель указывает на то место где располагается объект в куче. Все это вас почти не касается, но в java у переменных-объектов ссылочное поведение, в отличии от примитивов в которых хранятся значения. Вы это сможете различить воспользовавшись оператором присваивания:

```java
int a = 5, b;
b = a;
System.out.println("a = " + a + "; b = " + b + ";"); //=> a = 5; b = 5;
a = 9;
System.out.println("a = " + a + "; b = " + b + ";"); //=> a = 9; b = 5;

int[] c = new int[]{1, 2, 3};
int[] d = c;
//видимо так исторически сложилось что стандартный вывод массива выглядит не так как хотелось бы
//c.toString() вернет нам что-то вроде "[I@3343c8b3" первый символ говорит о том что это массив
//второй символ говорит о значениях массива и дальше по-видимому указатель в памяти
//хотя нам это совсем не нужно. Поэтому воспользуемся import java.util.Arrays;
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = "[1, 2, 3]"; d = "[1, 2, 3]";
c[0] = 5;
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = "[5, 2, 3]"; d = "[5, 2, 3]";
c = new int[]{4, 5, 6};
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = [4, 5, 6]; d = [5, 2, 3];
```

Возможно результат вам показался несколько нелогичным. Скорей всего поведение примитивов в первых двух примерах вам кажется наиболее естественным. В языках С и С++ в любом случае срабатывает присваивание по значению - это один из принципов языка. В ruby напротив все является объектом и передается по ссылке. В java вам стоит быть осторожным и запомнить эти небольшие правила. Разберем то, что произошло в случае с объектами: мы выделили память для трех целых чисел. Присвоили ссылку на область памяти в переменную `c` затем присвоили туже ссылку в переменную `d`. Далее мы модифицировали объект, но  `c` и `d` ссылаются по-прежнему на один и тот же объект поэтому при выводе кажется что изменились сразу обе переменные. Далее мы создаём новый объект присваиваем его переменной `c`, а `d` по-прежнему ссылается на старую переменную.

Не всегда присваивание по ссылке вас будет устраивать. Иногда хочется изменить одну переменную не затронув другую. Тогда нам следует *копировать* объект. Для этого у каждого объекта определен метод `clone()`. Но он зачастую избыточно медленный и лучше воспользоваться специальными методами если такие определены. Например для массивов есть статический метод `Arrays.copyOf(array)`. В общем у обоих методов результат один и тот же - в куче выделяется память под новый объект он инициализируется так чтобы быть идентичным тому которому указали и возвращается ссылка.

Арифметические операторы для объектов недоступны (исключением являются строки для которых доступен оператор конкатенации), операторы сравнения тоже, т.к. в общем случае нельзя сказать что будет обозначать объект плюс объект или объект больше чем объект (перегрузка операторов в java недоступна). Зато для объектов доступен операвтор проверки эквивалентности: `==` и `!=`. У него поведение также сбивает с толку как и уприсваивания.

```java
int[] c = new int[]{1, 2, 3};
int[] d = c;
if(c == d) // true
    System.out.println("c is equal d");
int[] d = new int[]{1, 2, 3};
if(c == d) // false
    System.out.println("c is equal d");
```

Здесь также поведение может быть для вас вполне очевидным если вы держите у себя в голове мысль о том, что переменные-объекты являются ссылками. Оператор эквивалентности проверяет равенство ссылок. Иногда это бывает полезно, но чаще вам необходимо проверить идентичность объектов независимо от их расположения в памяти. В таком случае у каждого объекта существует метод `equals(Object)`. Вообще полная проверка эквивалентности -занятие нетривиальное и у каждого класса должно быть реализовано по-своему. Поэтому метод реализован не у всех объектов и если не реализован то он работает также как и простой оператор `==`. Так например у массивов (странно что их так обделили). И для массивов придётся воспользоваться `Arrays.equals(Array, Array)`.

###null

Ноль (null, nil) в языках программирования появился уже очень давно. Разработчики java при разработке дизайна языка ориентировались на C++. Там нул используется повсеместно, но он не является специальным значением - это тот же ноль что и в целочисленных арифметических операциях (все поменялось с приходом c++11). Кроме того там с указателями допустимы многие арифметические операции вроде инкримента, сложения двух указателей. Такая свобода конечно доставляет огромную боль программистам. В java вы можете зачастую не думать о переменной как об указателе и никаких арифметических операций с указателем совершить нельзя. 

Таким образом java как бы даёт нам гарантии что в указанной переменной хранится объект, который может реагировать на методы данного типа (указанной переменной) и соответственно содержит поля типа. Но все эти гарантии ломает `null`. Переменной-объекту можно присвоить новый объект (корректный для данного типа), либо уже существующий объект (другую переменную), либо `null`. Причем если вы не проинициализируете переменную объект в ней будет содержаться именно `null`. Если вы вызовете метод на переменной объекте - это может вызвать ошибку при неправильных параметрах, либо может не соответствовать логике программы. Если вы вызовете метод (или обратитесь к полю), то это гарантировано приведет к ошибке. 

Поэтому рекомендуется стараться инициализировать переменные-объекты.

###autoboxing



**TODO побольше примеров объектов. отличия объектов от примитивов и автобоксинг**

В большинстве языков поддерживающих ООП сейчас преобладает концепция классов. То есть прежде чем создать объект вам необходимо определить класс. В некоторых динамически-типизированных языках можно создать объект определенного класса и позже доопределить новых свойств или переопределить старые. java - язык статически типизированный - все объекты приндлежат определенному типу и различаются между собой лишь в значениях но структура строго определена во время компиляции.

Итак класс. Класс представляет из себя последовательное определение полей и методов. Как вы уже знаете последовательность не важна. Но обычно все таки принято наводить порядок в классе и писать сначала поля затем методы. Как это выглядит:

```java
[private|public] class <имя класса>{
    //определение полей
    //final поля можно сразу инициализировать
    [private|public|protected] [static] [final] <тип> <имя> [= значение];
    //определение методов
    [private|public|protected] [static] <тип> <имя>(<аргументы через запятую>){
        //код
    }
    //определение конструкторов
    [private|public|protected] <имя класса>(<аргументы через запятую>){
        //код
    }
}
```

Для начала поясню нотацию: [] - не обязательно указывать. Угловые скобки - произвольное название. Всё остальное обязательно писать (например ключевое слово `class`). `[private|public|protected]` - называется модификатор доступа. Всё что `private` - доступно исключительно внутри класса, а `public` - доступно везде.

#####code style

Для составления имени класса существуют особые правила: Каждое отдельное слово начинается с заглавной буквы (в отличии от других сущностей вроде переменных и методов где первая буква прописная). По типу переменной вы можете отличить примитив от объекта по первой букве типа (хотя примитивы легко запомнить).

###пример cube

Создадим класс-композицию трех примитивов. Он будет представлять собой трехмерный паралепипед без определенного положения в пространстве.

```java
public class Block{
    public int width, height, depth;
}
```

Такой класс ничего не делает, лишь содержит данные. Использование класса для композиции данных уже является достаточным свойством чтобы использовать классы в своих программах. Например в паскале эту роль выполняет `Record`, а в С `struct`. Однако в java обычно классы сопровождаются интерфейсом (набором методов) для обращения к полям - таким образом программист который использует ваш класс сможет понять предназначение класса и возможно ему не придется обращаться к полям в памяти напрямую. Об этом позже. Вспомним, что для обращения к полю класса мы используем оператор `.`:

```java
Block cube = new Block();
cube.width = 3;
cube.height = 3;
cube.depth = 3;
System.out.printl("width is " + cube.width);
```

Как известно java итак проинициализирует поля нулями при создании объекта. Но явное лучше неявного. Так что сделаем это сами в конструкторе.

```java
public class Block{
    public int width, height, depth;
    //конструктор без параметров инициализирует поля нулями
    public Block(){
        width = 0;
        height = 0;
        depth = 0;
    }
    //конструктор задающей каждую сторону
    public Block(int w, int h, int d){
        width = w;
        height = h;
        depth = d;
    }
    //добавим для разнообразия метод возвращающий объём куба
    public int getValue(){
        return width*height*depth;
    }
}
```

##Спецификаторы доступа

В Java спецификаторы доступа **public**, **protected** и **private** располагаются перед определением членов классов — как полей, так и методов. Каждый спецификатор доступа управляет только одним отдельным определением. 

Если спецификатор доступа не указан, используется «пакетный» уровень доступа. Получается, что в любом случае действует та или иная категория доступа. В нескольких ближайших подразделах описаны разные уровни доступа.

###Доступ в пределах пакета

Во всех рассмотренных ранее примерах спецификаторы доступа не указывались. Доступ по умолчанию не имеет ключевого слова, но часто его называют доступом в пределах пакета (package access, иногда «дружественным»). Это значит, что член класса доступен для всех остальных классов текущего пакета, но для классов за пределами пакета он воспринимается как приватный (private). Так как компилируемый модуль — файл — может принадлежать лишь одному пакету, все классы одного компилируемого модуля автоматически открыты друг для друга в границах пакета. 

Доступ в пределах пакета позволяет группировать взаимосвязанные классы в одном пакете, чтобы они могли легко взаимодействовать друг с другом. Размещая классы в одном пакете, вы берете код пакета под полный контроль. Таким образом, только принадлежащий вам код будет обладать пакетным доступом к другому, принадлежащему вам же коду — и это вполне логично. Можно сказать, что доступ в пределах пакета и является основной причиной для группировки классов в пакетах. Во многих языках определения в классах организуются совершенно произвольным образом, но в Java придется привыкать к более жесткой логике структуры. Вдобавок классы, которые не должны иметь доступ к классам текущего пакета, следует просто исключить из этого пакета.

###private

Ключевое слово **private** означает, что доступ к члену класса не предоставляется никому, кроме методов этого класса.

Может показаться, что спецификатор доступа **private** применяется редко и можно обойтись и без него. Однако разумное применение **private** очень важно. На самом деле чаще всего вы будете предоставлять вне класса исключительно final поля, а доступ к внутренним полям скроете через методы возвращающие значение поля (геттеры) и методы устанавливающие значение (сеттеры). Конечно не всегда. Например иногда вам понадобится класс как композиция нескольких полей (как простейший пример выше). Но зачастую предоставлять прямое воздействие на состояние объекта опасно (может приводить к непрдесказуемому поведению объекта). А также опасно в плане сложности дальнейшей поддержки класса.

**привести пример**

###protected 

Понимание **protected** тесно связано с термином наследование. Забегая вперед можно сказать, что protected - тот же самый **private** только доступный в наследуемых классах. В основном стоит использовать **protected**, но пока что не будем заострять внимания.

###public

При использовании ключевого слова public вы фактически объявляете, что следующее за ним объявление члена класса доступно для всех, и прежде всего для клиентских программистов, использующих библиотеку. Когда вы пишете **public** стоит отдавать себе отчет - зачем нужен доступ к этому полю в внешнем коде.

#####code style

При заполнении класса полями существуют следющие правила: сначала пишутся public поля, затем protected, далее private. При написании методов таких правил нет. Обычно методы пишутся после полей. Методы лучше писать в том порядке, чтобы человеку читающему код был понятен смысл кода. 

#Доступ к классам

В Java с помощью спецификаторов доступа можно также указать, какие из классов внутри библиотеки будут доступны для ее пользователей. Если вы хотите, чтобы класс был открыт программисту-клиенту, то добавляете ключевое слово `public` для класса в целом. При этом вы управляете даже самой возможностью создания объектов данного класса программистом-клиентом. 

Для управления доступом к классу, спецификатор доступа записывается перед ключевым словом `class`: 

```java
public class Widget {}
```

Если ваша библиотека называется, например, `access`, то любой программист-клиент сумеет обратиться извне к классу `Widget`: 

```java
import access.Widget;
```

или

```java 
 import access *;
```

Впрочем, при этом действуют некоторые ограничения:

- В каждом компилируемом модуле может существовать только один открытый (public) класс. Идея в том, что каждый компилируемый модуль содержит определенный открытый интерфейс и реализуется этим открытым классом. В модуле может содержаться произвольное количество вспомогательных классов с доступом в пределах пакета. Если в компилируемом модуле определяется более одного открытого класса, компилятор выдаст сообщение об ошибке. 

- Имя открытого класса должно в точности совпадать с именем файла, в котором содержится компилируемый модуль, включая регистр символов. Поэтому для класса Widget имя файла должно быть Widget.java, но никак не widget.java или WIDGET.java. В противном случае вы снова получите сообщение об ошибке.

##static

Обычно при создании класса вы описываете, как объекты этого класса ведут себя и как они выглядят. Объект появляется только после того, как он будет создан ключевым словом new, и только начиная с этого момента для него выделяется память и появляется возможность вызова методов. 

Но есть две ситуации, в которых такой подход недостаточен. Первая — это когда некоторые данные должны храниться «в единственном числе» независимо от того, сколько было создано объектов класса. Вторая — когда вам потребуется метод, не привязанный ни к какому конкретному объекту класса (то есть метод, который можно вызвать даже при полном отсутствии объектов класса). 

Такой эффект достигается использованием ключевого слова static, делающего элемент класса статическим. Когда вы объявляете что-либо как static, это означает, что данные или метод не привязаны к определенному экземпляру этого класса. Поэтому, даже если вы никогда не создавали объектов класса, вы можете вызвать статический метод или получить доступ к статическим данным. С обычным объектом вам необходимо сначала создать его и использовать для вызова метода или доступа к информации, так как нестатические данные и методы должны точно знать объект, с которым работают. 

Некоторые объектно-ориентированные языки используют термины данные уровня класса и методы уровня класса, подразумевая, что данные и методы существуют только на уровне класса в целом, а не для отдельных объектов этого класса. Иногда эти термины встречаются в литературе по Java. 

Чтобы сделать данные или метод статическими, просто поместите ключевое слово static перед их определением. Например, следующий код создает статическое поле класса и инициализирует его:

```java
 class StaticTest {
  static int і = 42;
 }
 ```

Существует два способа обратиться к статической переменной. Вы можете указать ее с помощью объекта, например st2.i. Также можно обратиться к ней прямо по имени класса (для нестатических членов класса такая возможность отсутствует). Проверим наш класс:

```java
 StaticTest st1 = new StaticTest();
 StaticTest st2 = new StaticTest();
 st1.i = 1; //в обоих объектах общее поле равно 1
 StaticTest.i++; // = 2
```

Синтаксис с именем класса является предпочтительным, потому что он не только подчеркивает, что переменная описана как static, но и в некоторых случаях предоставляет компилятору больше возможностей для оптимизации.

Та же логика верна и для статических методов. Вы можете обратиться к такому методу или через объект, как это делается для всех методов, или в специальном синтаксисе имяКласса.метод(). Статические методы определяются по аналогии со статическими данными: 

```java
class Incrementable {
    static void increment () { StaticTest.i++; }
}
```

Нетрудно заметить, что метод `increment()` класса `Incrementable` увеличивает значение статического поля і. Метод можно вызвать стандартно, через объект: 

```java
   Incrementable sf = new Incrementable();
   sf.increment();
```

Или, поскольку `increment()` является статическим, можно вызвать его с прямым указанием класса: 

```java
  Incrementable.increment();
```

Применительно к полям ключевое слово static радикально меняет способ определения данных: статические данные существуют на уровне класса, в то время как нестатические данные существуют на уровне объектов, но в отношении изменения не столь принципиальны. Одним из важных применений static является определение методов, которые могут вызываться без объектов. В частности, это абсолютно необходимо для метода main(), который представляет собой точку входа в приложение.

##Ключевое слово this

this - ссылка на себя внутри методов объекта. Компилятор вынужден поддерживать это свойство, поэтому this не может находится с левой стороны присваивания. 

Мы можем использовать this чтобы
1. Присвоить что-либо текущему объекту (this в правой части присваивания).
2. Вернуть this из метода (выходит очень даже красиво, если заменять void на this).
3. Явно обратиться к полю текущего объекта (допустим объявлена локальная переменная с таким же имеменем как поле объекта. мы можем обратиться к локальной переменной как просто name, а к полю как this.name).

Если мы возврщаем this из метода, то мы можем писать вот такие цепочи `stack.push(o1).push(o2).push(o3);`.

###Вызов конструкторов из конструкторов

Если вы пишете для класса несколько конструкторов, иногда бывает удобно вызвать один конструктор из другого, чтобы избежать дублирования кода. Такая операция проводится с использованием ключевого слова this. Обычно при употреблении this подразумевается «этот объект» или «текущий объект», и само слово является ссылкой на текущий объект. В конструкторе ключевое слово this имеет другой смысл: при использовании его со списком аргументов вызывается конструктор, соответствующий данному списку. Таким образом, появляется возможность прямого вызова других конструкторов.

##final (инициализация)

Вы можете описывать поля своего класса как final. Очевидно при этом они будут константными - также как если бы это были локальные переменные, описываемые с final. Но обычно final для нас не очень гибки. То есть мы описываем исключительно числовые константы. Это иногда очень хорошо помогает избегать "магических чисел". То есть чисел взятых из ниоткуда.

```java
if(i > 0 && i < 7){ //why 7?
```

```java
final int firstDayOfWeek = 0;
final int daysInWeek = 7;
if(i > firstDayOfWeek && i < daysInWeek){
```

Но у final-поля есть ещё одно замечательное свойство. Мы можем инициализировать его в конструкторе. То есть мы объявляем final-поле в классе, но не инициализируем. Затем мы должны проинициализировать его во всех конструкторах. Вот пример.

```java
public class Stack{
    protected final int[] values;
    protected final int size;
    protected int pointer;
    public Stack(int size){
        this.size = size;
        values = new int[size];
        pointer = 0;
    }

    public Stack(){
        size = 100;
        values = new int[size];
        pointer = 0;
    }

    //very unsafe
    public Stack push(int value){
        values[pointer++] = value;
        return this;
    }

    public int pop(){
        return values[--pointer];
    }
}
```

#Порядок инициализации

Мы можем инициализирвоать поля класса прямо в описании.

```java
class Person{
    String firstName = "John";
    public Person(){
        firstName = "";
    }
    String secondName = "Smith";
```

Порядок в таком случае следующий: когда мы создаём объект (вызываем одини зи конструкторов) сначала исполняются все инициализации описанные в классе (это могут быть в том числе и методы выполняющие какую-либо работу). Затем исполняются все выражения описанные в конструкторе.

##static

Тоже самое можно проделать и для статических полей.

```java
class Person{
    static int count = 0;
    static Person lastPerson;
    static{
        lastPerson = null;
    }
}
```
Здесь мы также можем инициализировать поля по ходу их объявления сверху вниз. Затем исполняется блок `static` который как раз призван для сложной логики инициализации статических полей.

Объявляться поля начинают во время первой инициализации объекта указанного класса. Хотя правильнее сказать не во время, а в случае. То есть время инициализиации статических полей - это запуск программы, но они могут быть не проинициализированны, если в коде ни разу не используется класс.

#Наследование

В java как и во многих ООП языках поддержка наследования закреплена на уровне синтаксиса языка. Описывая свой класс мы можем указать его родительский класс от которого мы наследуемся. Мы делаем это с помоью ключевого слова `extends`. После этого слова мы записываем имя базового класса от которого мы собираемся унаследоваться. При наследовании наш класс получает от базового все поля, методы, конструкторы. При этом в наследуемом классе мы можем переопределить методы (ещё одна форма полиморфизма). Добавить новые методы и поля.

```java
class Manager extends Person{

}
```
Если мы не укажем явно, то будет считаться что наш класс унаследован от Object. Таким образом у нас сохраняется свойство однокорневой системы.

Теперь самое время рассказать про модификатор доступа **private** - если вы наследуетесь от базового класса у которого есть private поле, то у вас нет возможности обратиться к этому полю (из наследумого класса). У вас нет возможности переопределить или вызвать private метод. То есть если вы определяете своё поле как private вам стоит хорошо подумать - не может ли это поле пригодиться наследникам. Хотя если вы придете к выводу, что не может, то это будет правильным решением. То есть следует всегда исходить из наиболее защещенного состояния. Объявлять поля как private final не-static.

##Конструктор по умолчанию

Во-первых стоит сказать (если ещё не говорил), что из одного конструтора вы можете вызвать другой.

```java
class Person{
    String firstName, secondName;
    Person(String name, String lastName){
        firstName = name;
        secondName = lastname;
    }
    
    Person(){
        this("", "");
    }
}
```
Всё внимание на ключевое слово this во втором конструкторе. Из него мы вызываем первый передав параметры. Очень удобно, но правда есть одно условие, что конструктор (this) должен быть на первой строке.

Если у вас в классе описывается конструктор без аргументов, то этот конструктор будет назван конструктор по умолчанию. Где он может проявить себя? 

```
class A{
    A(){
        System.out.println("A");
    }
}

class B extends A{
    B(){
        System.out.println("B");
    }
}
```

Как вы уже догадались будет выведено А затем В, если мы создаём экземпляр класса B. То есть при создании объекта всегда будет конструктор и все конструкторы предков. Также мы можем указать явно какой конструктор мы собираем использовать, с помощью ключевого слова `super`.

```
class A{
    A(){
        System.out.println("A");
    }
    A(int i){
        System.out.println("A" + i);
    }
}

class B extends A{
    B(){
        super(1);
        System.out.println("B");
    }
}
```
Результат думаю очевиден. `super` также обзан быть на первой строке конструктора и поэтому он не сочетается с вызовом другого конструктора данного класса через `this`. 

##Зачем нам может пригодиться наследование?

###1. Повторное использование кода.
Допустим вы когда-то давно написали класс. Например парсер xml-ки. Он отлично справлялся со своей задачей успешно проходил тесты и вообще вам нравился и вы были довольны собой. 

Теперь перед вами стоит задача написть парсер html. Пример очень удачный так как html - частный случай xml. Конечно для проверки корректности html есть много своих нюансов. Да и скорей всего тот формат в который должен быть распарсен html несколько отличается (более частный случай). Но в целом суть таже самая. 

Примерная идея в том что можно тупо скопипастить ваш xml класс переименовать и подправить. В основном вас может мучить совесть что копипастить нехорошо, но это пустяки. Всё что работает - то хорошо. Реальный изъян этого решения в том что у парсера могла быть всё же реальная ошибка. Достаточно неуловимая, что её не заметили раньше, но достаточно критичная из-за которой логика программы нарушается. В последствии ошибка может быть устранена в xml парсере. Но в вашем html парсере она так и останется по причине:
1. лень исправлять.
2. Это уже измененный класс (тот кто исправил её в xml парсере может не найти в html так как сложно соотнести код)

И тут вам на помощь приходит наследование. Если вы большой молодец, то значит вы разбили ваш xml парсер на множество мелких методов, возможно сделали подклассы. И когда вы наследуетесь то вам остаётся переопределить некоторые методы в которых логика отличается. А при измении старых методов вы автоматически подписываетесь на них в наследуемом классе.

Но изменения базового класса вас же и погубят. Считается, что наследование - плохое решение для повторного использования кода.

Допустим время прошло, задачи поменялись. Теперь xml парсер должен предоставлять нечто большее. В хорошем случае это нечто большее унаследуется от xml-парсера. Или создаст класс-обертку над ним. Но может оказаться так, что все же измениться и сам класс. В таком случае перед разработчиком встают два пути: стараться изменять так чтобы это никак не отразилось на классах потомках, либо изменять все классы потомки в соответствии с полученными изменениями. Оба решения требуют достаточных усилий головного мозга. Поэтому принято избегать наследования там, где его можно избежать (хоть это вам и покажется странным - ведь казалось бы ООП это благо, а наследование почти основной инструмент ООП).

В таких ситуациях оптимальным решением считается **агрегирование**. То есть вы в свой хтмл класс включаете как поле xml класс который парсит и выдаёт файл в своём формате, а html обрабатывает этот формат и представляет его по своему, и заодно проверяет корректность полей. 

Правда дело в том, что этот пример слишком хороший. Да и даже учитывая, что он хороший, существуют некоторые корректные html записи, которые некорректны для общего случая xml. Так что пришлось бы подправлять агрегируемый класс, задавать ему специальный аргумент чтобы тот закрывал иногда глаза на корректность файла.

##2. Иерархия классов

Правильное применение наследования это создание иерархии классов. Правда вы можете возразить, что и в прошлом примере мы создавали иерархию, но в прошлом примере это было как бы нагромождение над существующей системой, а здесь речь идёт о планировании системы заранее.

В качестве примера системы приведу 2D игру-платформер. У нас есть библиотека (например OpenGL). Она предоставляет нам возможность отрисовывать примитивы. И ещё есть библиотека (допустим таже что и предоставляет нам отрисовку графики), которая даёт возможность реагировать на нажатие клавиш. 

Вообще оргнизация событий в вашем коде задача весьма нетривиальная, но эти детали мы опустим.

Итак нам предстоит отрисовывать динамичный игровой мир в зависимости от нажатия клавиш. Это немного сложновато делать напрямую. Мы организуем систему классов, которая будет симулировать игровой мир. 

Во-первых мы отдём себе отчет в том что есть персонаж который (единственный) реагирует на нажатие клавиш. Назовём такой класс Player. Также мы понимаем что в игре будут встречаться разного рода графические объекты. Некоторый из них статические, другие обладают некоторой физикой (при столкновении отбрасываются), другие могут срабатывать при нажатии, ударе. 

Также у нас есть класс Engine. Который инициализирует графическую систему, подписывается на нажатия клавиш. Он будет содержать все графические объекты и игрока. С графическими объектами он будет в отношении делегирования. То есть графическая система будет запрашивать отрисовку у нашего движка, а наш движок будет перенаправлять запросы во все вложенные графические объекты.

Чтож пеернаправим наши измышления в код.

```java
Class Mesh{
    float up, down, right, left;
    void draw(){}
    void onCollision(Mesh mesh){}
}

Class Engine{
    private Mesh[] meshes;
    private Player player;
    Engine(){
        //инициализируем графическую систему
        //подписываемся на нажатия клавиш
        //читаем файл хранящий положение всех объектов на карте
        //инициализируем массив с мешами записываем туда все нужные объекты и игрока
        
    }
    void onDraw(){
        for(int i = 0; i < meshes.length; i++)
            meshes.draw()
    }
    void onKeyPress(int keyCode){
        if(keyCode  == Keys.UP)
            player.move(Direcion.UP);
        for(int i = 0; i < meshes.length; i++)
            for(int i = 0; i < meshes.length; i++)
                //нужно проверить все коллизии
        
    }
}

class Player extends Mesh{
    @override
    void onCollision(Wall wall){
        //каким-нибудь образом отменяем последнее движение в сторону стены
    }
    
    @override
    void onCollision(Trap trap){
        //смерть
    }
    
    void Move(Direction dir){
    
    }
}

class Wall extends Mesh{

}

class Trap extends Mesh{

}

```
#Домашнее задание

**TODO apachecommons** численное интегрирование
