#ООП

##Предисловие

Java в отличии от многих других высоко-уровневых языков ограничивает программиста в плане выбора парадигмы для написания кода. Например лисп изначально создавался с поддержкой мета-программирования и код было принято писать в функциональном стиле. Но также нет никаких ограничений чтобы писать императивный код. И впоследствии было сделано много реализаций системы классов для Common Lisp благодаря чему можно писать и в ООП стиле. С одной стороны гибкость языка кажется замечательным свойством. Противоположность для гибкости - строгость. Строгость также замечательное свойства. Гибкие языки часто необходимы при решении задач, имеющих исследовательский характер. Таких которые раньше не решали. Изначально, когда CS только зарождалось таких задач было большинство и постепенно появлялись общие подходы, шаблоны. В наше время задач требующих исследований по-прежнему немало. Количественно их больше чем было раньше. Но процентно их гораздо меньше. То есть устраиваясь на работу от вас потребуются прикладные навыки как например работа с базой данных с UI и тп. 

В таких условиях от языка программирования требуется надежность, определенность поведения (документированность), и строгость в плане подхода к решению задачи. Хотя наверное основным фактором успеха джавы в своё время стала кроссплатформенность и то что у джавы на разных платформах код работает одинаково в отлчиии от С где нет никаких гарантий что инт останется интом (простой поверхностный пример). 

Ещё раз насчет строгости гибкости. Про perl говорят, что у него есть 10 решений для одной задачи. Это считается нормой что программист использует разные конструкции для похожих задач. В основном пытаясь достичь выразительности и лаконичности кода. Программируя на джава вы жертвуете лаконичностью, зато взглянув на код вашего сотрудника, насколько бы он не был убог или запутан вы скорее всего догадаетесь что к чему. Конечно всегда есть возможность сделать все сложнее. Просто джава не располагает для этого средствами.

##Мотивация

Вы уже можете запрограммировать что угодно, т.к. располагаете знаниями о базовых операторах и конструкциях языка (ветвление, циклы). Вы уже можете писать код лаконичнее без лишних повторов используя функции. Давая переменным и функциям хорошие выразительные названия вы можете писать самодокументируемый код. На этом занятии мы впервые ознакомимся с составными структурами данных (до этого мы использовали примитивы в своих программах ну и ещё массивы примитивов). Также мы предоставим методы для обработки структур данных. Ознакомимся с базовыми понятиями ООП: наследование инкапсуляция полиморфизм. 

##Объекты

Для начала попробуем взглянуть на объекты как пользователи (всмысле пользователь чужого кода), позже разработаем свои объекты.
Объект по своей сути - структура хранящаяся в памяти. У этой струтуры имеется доступ к её полям (некоторые поля скрыты из внешнего кода, но об этом позже). Чтобы выделить в памяти место под наш объект мы используем оператор `new` который кроме выделения памяти также вызывает конструктор (по своей сути - обычная функция, только вызывается единожды при создании объекта). Как вы уже могли заметить оператор `.` (точка) позволяет обращаться к полям объекта. Поля у объекта бывают двух видов - во-первых поле-значение (далее буду иметь ввиду именно его говоря "поле"), которое также относится к памяти (может быть примитивом или другим объектом, как переменная). Во-вторых поле-функция или метод. Простейший пример объекта:

```java
Object object = new Object();
//Здесь мы: 1. инициализируем область в памяти под объект класса Object.
//2. Вызываем конструктор без параметров.
//3. Присваиваем его новой переменной с типом Object и названием object.  
System.out.println(object.toString());
//обращаемся к методу toString() (на самом деле он бы и так вызвался если бы мы передали объект)
```
На деле нам редко придётся создавать объекты класса Object - он наиболее абстрактный класс и с ним мы ничего делать не можем.

Например возмём знакомый нам массив. Он также является объектом, но с некоторым синтаксическим сахаром. 

Синтаксический сахар с том что мы объявляем его с записью отличающейся от других объектов - `int a[17];` или например берем значения через `a[1]` заместо `a.get(1);`. Это очень даже удобно, просто самостоятельно мы не сможем сделать подобного поведения. Тем не менее у массива есть поведение похожее на обычный объект:

```java
int a[] = {1, 2, 3, 4, 5};
//массив хранит поле в котором указывается количество элементов - обратимся к нему:
System.out.println(a.length); // => 5 
//никаких особых методов у массива не определено кроме тех же что у Object
```

Раз уж зашла речь про организацию памяти, то необходимо рассказать как память организуется в машине (всмысле на компьютере). Зачастую языки программирования стараются как можно больше абстрагироваться от реального железа, которое производит вычислительные операции. Но по причинам производительности те или иные детали вылазят в наружу.

Итак вам уже должно быть известно что память бывает внутренняя (оператива) и внешняя (жесткий диск, сеть и тд). В программе мы имеем дело с внутренней памятью и иногда нам приходится обращаться к внешней (например ваши домашние задания зачастую будут читать input.txt и записывать результат в output.txt). Рассмотрим подробнее внутреннюю память:

1. Регистры. Самое быстрое хранилище, процессор производит вычислительные операции обращаясь к регистрам. Их в наших домашних компьютерах совсем немного и про работу с ними вам не обязательно знать (до тех пор пока у вас не начнется курс по ассемблеру). Из java у вас нет никакого доступа к регистрам.

2. Кеш. Очень быстрое хранилище. Не обязательно присутствует в процессоре. Представляет из себя часть сохраненной оперативной памяти и служит для более быстрой загрузки данных из оперативы в регистры. Вам будет полезно знать про работу кеша - с ним связано такое понятие как "локальность данных". Но видимо вы познакомитесь с ним также на курсе по ассемблеру или устройству эвм.

3. Стек.  Эта область хранения данных находится в общей оперативной памяти (RAM), но процессор предоставляет прямой доступ к ней с использованием указателя стека. Указатель стека перемещается вниз для выделения памяти или вверх для ее освобождения. То есть по скорости обращения к данным - стек таже оперативная память, но выделение и освобождение ничего не стоят. Компилятор обязан знать время жизни данных хранящихся в стеке. Ещё одно ограничение - размер стека. Вы могли с ним познакомиться во время работы с рекурсией. Из-за небольшого размера в стеке не хранятся большие объекты (например строки массивы). В стеке принято хранить все глобальные (статические) и локальные переменные. Если ваша переменная представляет собой примитив то в стек прямо кладётся значение (число) и компилятор производит операции напрямую с этим число зная его положение в стеке.

4. Куча. Пул памяти общего назначения (находится также в RAM), в котором размещаются все объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго просуществуют находящиеся там объекты. Таким образом, работа с кучей дает значительное преимущество в гибкости. Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти из кучи занимает больше времени, чем в стеке. 

5. Постоянная память. Значения констант часто встраиваются прямо в код программы, так как они неизменны. Иногда такие данные могут размещаться в постоянной памяти (ROM), если речь идет о «встроенных» системах.

Итак что происходит когда вы пишете new? В куче выделяется память размером с ваш объект. В объекте срабатывает конструктор - инициализируются поля объекта. После этого объект присваивается переменной - в стеке выделяется поле размером с указатель (на 64-битных ОС размер этого поля будет 64 бита = 8 байт) и этот указатель указывает на то место где располагается объект в куче. Все это вас почти не касается, но в java у переменных-объектов ссылочное поведение, в отличии от примитивов в которых хранятся значения. Вы это сможете различить воспользовавшись оператором присваивания:

```java
int a = 5, b;
b = a;
System.out.println("a = " + a + "; b = " + b + ";"); //=> a = 5; b = 5;
a = 9;
System.out.println("a = " + a + "; b = " + b + ";"); //=> a = 9; b = 5;

int[] c = new int[]{1, 2, 3};
int[] d = c;
//видимо так исторически сложилось что стандартный вывод массива выглядит не так как хотелось бы
//c.toString() вернет нам что-то вроде "[I@3343c8b3" первый символ говорит о том что это массив
//второй символ говорит о значениях массива и дальше по-видимому указатель в памяти
//хотя нам это совсем не нужно. Поэтому воспользуемся import java.util.Arrays;
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = "[1, 2, 3]"; d = "[1, 2, 3]";
c[0] = 5;
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = "[5, 2, 3]"; d = "[5, 2, 3]";
c = new int[]{4, 5, 6};
System.out.println("c = " + Arrays.toString(c) + "; d = " + Arrays.toString(d) + ";");
//=> c = [4, 5, 6]; d = [5, 2, 3];
```

Возможно результат вам показался несколько нелогичным. Скорей всего поведение примитивов в первых двух примерах вам кажется наиболее естественным. В языках С и С++ в любом случае срабатывает присваивание по значению - это один из принципов языка. В ruby напротив все является объектом и передается по ссылке. В java вам стоит быть осторожным и запомнить эти небольшие правила. Разберем то, что произошло в случае с объектами: мы выделили память для трех целых чисел. Присвоили ссылку на область памяти в переменную `c` затем присвоили туже ссылку в переменную `d`. Далее мы модифицировали объект, но  `c` и `d` ссылаются по-прежнему на один и тот же объект поэтому при выводе кажется что изменились сразу обе переменные. Далее мы создаём новый объект присваиваем его переменной `c`, а `d` по-прежнему ссылается на старую переменную.

Не всегда присваивание по ссылке вас будет устраивать. Иногда хочется изменить одну переменную не затронув другую. Тогда нам следует *копировать* объект. Для этого у каждого объекта определен метод `clone()`. Но он зачастую избыточно медленный и лучше воспользоваться специальными методами если такие определены. Например для массивов есть статический метод `Arrays.copyOf(array)`. В общем у обоих методов результат один и тот же - в куче выделяется память под новый объект он инициализируется так чтобы быть идентичным тому которому указали и возвращается ссылка.

Арифметические операторы для объектов недоступны (исключением являются строки для которых доступен оператор конкатенации), операторы сравнения тоже, т.к. в общем случае нельзя сказать что будет обозначать объект плюс объект или объект больше чем объект (перегрузка операторов в java недоступна). Зато для объектов доступен операвтор проверки эквивалентности: `==` и `!=`. У него поведение также сбивает с толку как и уприсваивания.

```java
int[] c = new int[]{1, 2, 3};
int[] d = c;
if(c == d) // true
    System.out.println("c is equal d");
int[] d = new int[]{1, 2, 3};
if(c == d) // false
    System.out.println("c is equal d");
```

Здесь также поведение может быть для вас вполне очевидным если вы держите у себя в голове мысль о том, что переменные-объекты являются ссылками. Оператор эквивалентности проверяет равенство ссылок. Иногда это бывает полезно, но чаще вам необходимо проверить идентичность объектов независимо от их расположения в памяти. В таком случае у каждого объекта существует метод `equals(Object)`. Вообще полная проверка эквивалентности -занятие нетривиальное и у каждого класса должно быть реализовано по-своему. Поэтому метод реализован не у всех объектов и если не реализован то он работает также как и простой оператор `==`. Так например у массивов (странно что их так обделили). И для массивов придётся воспользоваться `Arrays.equals(Array, Array)`.

###null

Ноль (null, nil) в языках программирования появился уже очень давно. Разработчики java при разработке дизайна языка ориентировались на C++. Там нул используется повсеместно, но он не является специальным значением - это тот же ноль что и в целочисленных арифметических операциях (все поменялось с приходом c++11). Кроме того там с указателями допустимы многие арифметические операции вроде инкримента, сложения двух указателей. Такая свобода конечно доставляет огромную боль программистам. В java вы можете зачастую не думать о переменной как об указателе и никаких арифметических операций с указателем совершить нельзя. 

Таким образом java как бы даёт нам гарантии что в указанной переменной хранится объект, который может реагировать на методы данного типа (указанной переменной) и соответственно содержит поля типа. Но все эти гарантии ломает `null`. Переменной-объекту можно присвоить новый объект (корректный для данного типа), либо уже существующий объект (другую переменную), либо `null`. Причем если вы не проинициализируете переменную объект в ней будет содержаться именно `null`. Если вы вызовете метод на переменной объекте - это может вызвать ошибку при неправильных параметрах, либо может не соответствовать логике программы. Если вы вызовете метод (или обратитесь к полю), то это гарантировано приведет к ошибке. 

Поэтому рекомендуется стараться инициализировать переменные-объекты.

###autoboxing



**TODO побольше примеров объектов. отличия объектов от примитивов и автобоксинг**

В большинстве языков поддерживающих ООП сейчас преобладает концепция классов. То есть прежде чем создать объект вам необходимо определить класс. В некоторых динамически-типизированных языках можно создать объект определенного класса и позже доопределить новых свойств или переопределить старые. java - язык статически типизированный - все объекты приндлежат определенному типу и различаются между собой лишь в значениях но структура строго определена во время компиляции.

Итак класс. Класс представляет из себя последовательное определение полей и методов. Как вы уже знаете последовательность не важна. Но обычно все таки принято наводить порядок в классе и писать сначала поля затем методы. Как это выглядит:

```java
[private|public] class <имя класса>{
    //определение полей
    //final поля можно сразу инициализировать
    [private|public|protected] [static] [final] <тип> <имя> [= значение];
    //определение методов
    [private|public|protected] [static] <тип> <имя>(<аргументы через запятую>){
        //код
    }
    //определение конструкторов
    [private|public|protected] <имя класса>(<аргументы через запятую>){
        //код
    }
}
```

Для начала поясню нотацию: [] - не обязательно указывать. Угловые скобки - произвольное название. Всё остальное обязательно писать (например ключевое слово `class`). `[private|public|protected]` - называется модификатор доступа. Всё что `private` - доступно исключительно внутри класса, а `public` - доступно везде.

#####code style

Для составления имени класса существуют особые правила: Каждое отдельное слово начинается с заглавной буквы (в отличии от других сущностей вроде переменных и методов где первая буква прописная). По типу переменной вы можете отличить примитив от объекта по первой букве типа (хотя примитивы легко запомнить).

###пример cube

Создадим класс-композицию трех примитивов. Он будет представлять собой трехмерный паралепипед без определенного положения в пространстве.

```java
public class Block{
    public int width, height, depth;
}
```

Такой класс ничего не делает, лишь содержит данные. Использование класса для композиции данных уже является достаточным свойством чтобы использовать классы в своих программах. Например в паскале эту роль выполняет `Record`, а в С `struct`. Однако в java обычно классы сопровождаются интерфейсом (набором методов) для обращения к полям - таким образом программист который использует ваш класс сможет понять предназначение класса и возможно ему не придется обращаться к полям в памяти напрямую. Об этом позже. Вспомним, что для обращения к полю класса мы используем оператор `.`:

```java
Block cube = new Block();
cube.width = 3;
cube.height = 3;
cube.depth = 3;
System.out.printl("width is " + cube.width);
```

Как известно java итак проинициализирует поля нулями при создании объекта. Но явное лучше неявного. Так что сделаем это сами в конструкторе.

```java
public class Block{
    public int width, height, depth;
    //конструктор без параметров инициализирует поля нулями
    public Block(){
        width = 0;
        height = 0;
        depth = 0;
    }
    //конструктор задающей каждую сторону
    public Block(int w, int h, int d){
        width = w;
        height = h;
        depth = d;
    }
    //добавим для разнообразия метод возвращающий объём куба
    public int getValue(){
        return width*height*depth;
    }
}
```

##Спецификаторы доступа

В Java спецификаторы доступа **public**, **protected** и **private** располагаются перед определением членов классов — как полей, так и методов. Каждый спецификатор доступа управляет только одним отдельным определением. 

Если спецификатор доступа не указан, используется «пакетный» уровень доступа. Получается, что в любом случае действует та или иная категория доступа. В нескольких ближайших подразделах описаны разные уровни доступа.

###Доступ в пределах пакета

Во всех рассмотренных ранее примерах спецификаторы доступа не указывались. Доступ по умолчанию не имеет ключевого слова, но часто его называют доступом в пределах пакета (package access, иногда «дружественным»). Это значит, что член класса доступен для всех остальных классов текущего пакета, но для классов за пределами пакета он воспринимается как приватный (private). Так как компилируемый модуль — файл — может принадлежать лишь одному пакету, все классы одного компилируемого модуля автоматически открыты друг для друга в границах пакета. 

Доступ в пределах пакета позволяет группировать взаимосвязанные классы в одном пакете, чтобы они могли легко взаимодействовать друг с другом. Размещая классы в одном пакете, вы берете код пакета под полный контроль. Таким образом, только принадлежащий вам код будет обладать пакетным доступом к другому, принадлежащему вам же коду — и это вполне логично. Можно сказать, что доступ в пределах пакета и является основной причиной для группировки классов в пакетах. Во многих языках определения в классах организуются совершенно произвольным образом, но в Java придется привыкать к более жесткой логике структуры. Вдобавок классы, которые не должны иметь доступ к классам текущего пакета, следует просто исключить из этого пакета.

###private

Ключевое слово **private** означает, что доступ к члену класса не предоставляется никому, кроме методов этого класса.

Может показаться, что спецификатор доступа **private** применяется редко и можно обойтись и без него. Однако разумное применение **private** очень важно. На самом деле чаще всего вы будете предоставлять вне класса исключительно final поля, а доступ к внутренним полям скроете через методы возвращающие значение поля (геттеры) и методы устанавливающие значение (сеттеры). Конечно не всегда. Например иногда вам понадобится класс как композиция нескольких полей (как простейший пример выше). Но зачастую предоставлять прямое воздействие на состояние объекта опасно (может приводить к непрдесказуемому поведению объекта). А также опасно в плане сложности дальнейшей поддержки класса.

**привести пример**

###protected 

Понимание **protected** тесно связано с термином наследование. Забегая вперед можно сказать, что protected - тот же самый **private** только доступный в наследуемых классах. В основном стоит использовать **protected**, но пока что не будем заострять внимания.

###public

При использовании ключевого слова public вы фактически объявляете, что следующее за ним объявление члена класса доступно для всех, и прежде всего для клиентских программистов, использующих библиотеку. Когда вы пишете **public** стоит отдавать себе отчет - зачем нужен доступ к этому полю в внешнем коде.

#####code style

При заполнении класса полями существуют следющие правила: сначала пишутся public поля, затем protected, далее private. При написании методов таких правил нет. Обычно методы пишутся после полей. Методы лучше писать в том порядке, чтобы человеку читающему код был понятен смысл кода. 

#Доступ к классам

В Java с помощью спецификаторов доступа можно также указать, какие из классов внутри библиотеки будут доступны для ее пользователей. Если вы хотите, чтобы класс был открыт программисту-клиенту, то добавляете ключевое слово `public` для класса в целом. При этом вы управляете даже самой возможностью создания объектов данного класса программистом-клиентом. 

Для управления доступом к классу, спецификатор доступа записывается перед ключевым словом `class`: 

```java
public class Widget {}
```

Если ваша библиотека называется, например, `access`, то любой программист-клиент сумеет обратиться извне к классу `Widget`: 

```java
import access.Widget;
```

или

```java 
 import access *;
```

Впрочем, при этом действуют некоторые ограничения:

- В каждом компилируемом модуле может существовать только один открытый (public) класс. Идея в том, что каждый компилируемый модуль содержит определенный открытый интерфейс и реализуется этим открытым классом. В модуле может содержаться произвольное количество вспомогательных классов с доступом в пределах пакета. Если в компилируемом модуле определяется более одного открытого класса, компилятор выдаст сообщение об ошибке. 

- Имя открытого класса должно в точности совпадать с именем файла, в котором содержится компилируемый модуль, включая регистр символов. Поэтому для класса Widget имя файла должно быть Widget.java, но никак не widget.java или WIDGET.java. В противном случае вы снова получите сообщение об ошибке.

##static

Обычно при создании класса вы описываете, как объекты этого класса ведут себя и как они выглядят. Объект появляется только после того, как он будет создан ключевым словом new, и только начиная с этого момента для него выделяется память и появляется возможность вызова методов. 

Но есть две ситуации, в которых такой подход недостаточен. Первая — это когда некоторые данные должны храниться «в единственном числе» независимо от того, сколько было создано объектов класса. Вторая — когда вам потребуется метод, не привязанный ни к какому конкретному объекту класса (то есть метод, который можно вызвать даже при полном отсутствии объектов класса). 

Такой эффект достигается использованием ключевого слова static, делающего элемент класса статическим. Когда вы объявляете что-либо как static, это означает, что данные или метод не привязаны к определенному экземпляру этого класса. Поэтому, даже если вы никогда не создавали объектов класса, вы можете вызвать статический метод или получить доступ к статическим данным. С обычным объектом вам необходимо сначала создать его и использовать для вызова метода или доступа к информации, так как нестатические данные и методы должны точно знать объект, с которым работают. 

Некоторые объектно-ориентированные языки используют термины данные уровня класса и методы уровня класса, подразумевая, что данные и методы существуют только на уровне класса в целом, а не для отдельных объектов этого класса. Иногда эти термины встречаются в литературе по Java. 

Чтобы сделать данные или метод статическими, просто поместите ключевое слово static перед их определением. Например, следующий код создает статическое поле класса и инициализирует его:

```java
 class StaticTest {
  static int і = 42;
 }
 ```

Существует два способа обратиться к статической переменной. Вы можете указать ее с помощью объекта, например st2.i. Также можно обратиться к ней прямо по имени класса (для нестатических членов класса такая возможность отсутствует). Проверим наш класс:

```java
 StaticTest st1 = new StaticTest();
 StaticTest st2 = new StaticTest();
 st1.i = 1; //в обоих объектах общее поле равно 1
 StaticTest.i++; // = 2
```

Синтаксис с именем класса является предпочтительным, потому что он не только подчеркивает, что переменная описана как static, но и в некоторых случаях предоставляет компилятору больше возможностей для оптимизации.

Та же логика верна и для статических методов. Вы можете обратиться к такому методу или через объект, как это делается для всех методов, или в специальном синтаксисе имяКласса.метод(). Статические методы определяются по аналогии со статическими данными: 

```java
class Incrementable {
    static void increment () { StaticTest.i++; }
}
```

Нетрудно заметить, что метод `increment()` класса `Incrementable` увеличивает значение статического поля і. Метод можно вызвать стандартно, через объект: 

```java
   Incrementable sf = new Incrementable();
   sf.increment();
```

Или, поскольку `increment()` является статическим, можно вызвать его с прямым указанием класса: 

```java
  Incrementable.increment();
```

Применительно к полям ключевое слово static радикально меняет способ определения данных: статические данные существуют на уровне класса, в то время как нестатические данные существуют на уровне объектов, но в отношении изменения не столь принципиальны. Одним из важных применений static является определение методов, которые могут вызываться без объектов. В частности, это абсолютно необходимо для метода main(), который представляет собой точку входа в приложение.

##final (инициализация)


Домашнее задание

**TODO apachecommons** численное интегрирование