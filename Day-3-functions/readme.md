

##Операторы break и continue

Дополнение к первому занятию. В циклах есть операторы безусловного перехода к концу или к началу цикла. Иными словами - безопасная версия `goto`. Оператор `break` переходит к концу цикла. То есть выходит из цикла. А оператор continue переходит в начало. То есть прекращает текущее исполнение и начинает с начала. Не стоит понимать что "начинает с начала" значит в цикле for переменные устнаовятся на начальное значение. Просто выполнится проверка цикла на завершение и все пойдёт дальше.

 Бывает ситуация когда вы хотите выйти сразу из двух циклов. Тут уж ничего не поделаешь. Двойного тройного break не прдусмотрено.

#Функции
Функции являются базовым понятием во многих языках. Они помогают орагнизовывать код. То есть мы могли бы использовать у себя в программах операторы языка + конструкции ветвления без функций. Но тем самым наш код выглядел бы менее выразительно и многие блоки кода многократно бы повторялись.

Изначально функции были представлены как подпрограммы (subroutines) и их основная цель была избавиться от повторов кода. У подпрограммы есть имя - правильное имя подпрограммы может неплохо объяснить назначение кода. Подпрограмма - очень старое название. Сейчас чаще называют процедура (хотя в зависимости от языка эти слова могут иметь разное значение). Суть одна и таже - вы пишете блок кода даёте ему наименование и потом в нужный момент вызываете. Сразу приведу пример процедур для вывода в консоль разделителя (между записями лога) и текущей даты.

```java
static void logDevider(){
    System.out.println("=========================");
}

static void logTime(){
    Date date = new Date();
    System.out.print("Log at: " + date + "; ");
}
```

Для разделителя всё до безобразия просто. Для вывода даты посложнее - приходится создавать объект, но сейчас это не важно. Функции мы уже вызывали раньше (например `println`), на всякий случай приведу пример вызова вышестоящих функций. 

```java
if(!wellDoneFlag){
    logDevider();
    logTime();
    System.out.println("something went wrong.");
}
else{
    logDevider();
    logTime();
    System.out.println("Huge success!");
}
```

Также имеются входные параметры (аргументы), которые позволяют сделать код более общим (гибким). На самом деле, когда мы пишем код непрерывно, то входными параметрами для блока служат все локальные переменные. Когда мы пишем функцию мы ограничиваем количество входных параметров. При большом количестве локальных переменных, то есть при разрастании непрерывного кода проще запустаться, поэтому принято разделять код на функции. Существует рекомендацию что размер функции должен не превышать два экрана. В то время экраны были символов 25 в высоту и 80 в ширину, хотя могу ошибаться. Входным параметрам также даются имена и они также помогают понять предназначение подпрограммы. Выше можно заметить повторение кода, поэтому сделаем процедуру - композицию из двух наших функций и println с одним входным параметром.

```java
static void log(String message){
    logDevider();
    logTime();
    System.out.println(message);
}
```

Обычно когда говорят функция, подразумевается что кроме входных данных имеются ещё и выходные. Такую сущность можно соотнести с математической функцией. Например факториал, который принимает и возвращает целое число или синус, который принимает и возвращает вещественное число (на самом деле комплексное тоже). Или логарифм у которого два параметра. Но всё же зачастую функции в языках программирования не совпадают с математичискими функциями. В математике функция при одинаковых входным параметрах должна возвращать одинаковый результат, в то время как мы можем запрограммировать функцию, которая возвращает рандом. Также в процессе выполнения наши функции могут работать с файлами, сетью и т.д.

К примеру простая функция проверяющая четность числа:

```java 
static bool isEven(int number){
    return number % 2 == 0;
}
```

Здесь мы видим новый оператор. Давайте для начала обобщим полученные знания о нотации функций:

```
[модификаторы] [возвращаемый тип] <имя функции>([список операторов через запятую]){
    [список выражений];
}
```

О модификаторах позже. Пока будем использовать statiс. Возвращаемый тип до этого мы писали void.`void` - один из примитивов, но в отличии от остальных он не занимает места в памяти. В java его используют чтобы показать что функция ничего не возвращает. Если же функция что-то возвращает, то необходимо, чтобы все ветки функции пришли к return. `return` оператор возврата значения, которое мы напишем после него. Кроме того return завершает выполнение функции, то есть совершает безусловный переход. Таким образом return может быть несколько, важно чтобы возвращаемое значение совпадало с указанным в заголовке функции (либо приводилось). Если ваша функция имеет тип void и вы хотите воспользоваться безусловным переходом, то можете написать `return;`.

В языке java функции и переменные должны описываться в классах (невозможно описать функцию вне класса). Функции привязанные к классу обычно называют методы. Можно это переформулировать так, что в java нет функций, но есть методы. Хотя в основном это не имеет особого смысла. 

Функцию мы можем описать с ключевым словом `static` то есть привязав функцию к классу. И без него нестатическая функция будет привязана к объекту. Вообще говоря поведение статической функции ничем не отличается от обычной функции как в других языках программирования. В то время как для нестатической требуется некоторое долнительное объяснение, которое будет приведено позже. Пока что каждую функцию будем писать со словом `static`. Также как мы это делали с `main`.


#Полиморфизм

В естественном языке слова в зависимости от констекста могут принимать разное значение. Такой же трюк можно провернуть и в программировании (хотя иногда это запутывает, но близость к естественной речи может показаться элегантной). 

Мы можем написать две разные реализации функции с одним имененм, но разными параметрами.

```java
/**
 * @return numeric position of first found element or -1 if not found
 */
int search(int[] array, int item){
    for(int i = 0; i < array.length; ++i){
        if(array[i] == item)
            return i;
    }
    return -1;
}

/**
 * @return numeric position of first found element or default if not found
 */
int search(int[] array, int item, int default){
    int result = search(array, item);
    return result == -1? default : result;
}
```

Обратите внимание на использование `return` в первом примере: если условие сработает мы возвращаем найденный элемент и выполнение прекращается. Если условие в цикле ни разу не сработало, то цикл завершается и переходим к конструкции `return -1;`. Далее мы функции перегружаем добавив аргумент, который принимает значение по умолчанию. Чтобы реализовать новую функцию, мы вызываем старую и используем тернарный оператор. Вообще все выглядело более элегантно, если бы мы использовали наиболее общую функцию и в частных бы вызывали её с частными аргументами, например `search(array, item, -1)`, но зачастую мы мыслим исходя из наиболее простых задач постепенно достигая сложных.

Всё что объединяет перегружаемые функции - это имя, поэтому перегружаемые функции могут иметь разный возвращаемый тип.

```java
int sum(int[] array){
    int result = 0;
    for(int i = 0; i < array.length; ++i)
        result += array[i];
    return result;
} 

float sum(float[] array){
    float result = 0;
    for(int i = 0; i < array.length; ++i)
        result += array[i];
    return result;
}

...
```

Перегруження функция имеет конечно полезную цель - мы можем просуммировать элементы массива независимо от типа, но в целом пример не очень удачный - для этого больше подойдут `generic` - средства для обобщенного программирования. Вот если бы у нас был разный код - разная логика для обработки разных аргументов - здесь хорошо подходит перегрузка.

При перегрузке у нас есть некоторое ограничение - мы не можем перегрузить возвращаемый тип. Теоретически возможно сделать в компиляторе такую возможность (чтобы компилятор пытался угадать необходимую реализацию функции исходя из контекста), однако её необходимость под сомнением.

#Рекурсия

Вы уже могли заметить, что нам не составляло никакого труда комбинировать функции - то есть в одной функции вызывать другую. Никаких проблем мы не встретим если внутри функции вызовем её саму.

```java
static void someFunction(){
    someFunction();
}
```

Такая конструкция вполне уместна, однако в нашем случае она будет длиться бесконечно. Это анологично `while(true){}`. Такая комбинация называется рекурсией. Впринципе возможна комбинация когда одна функция вызывает другую, а другая первую. В таком случае можно сказать, что эта конструкция является рекурсией, но в жизни такие цепочки возникают редко - выходит очень запутанно.

Ценность рекурсии в том что она может заменять циклы. В языке lisp например рекурсия более предпочтительна, чем циклы. У рекурсии есть некоторые преймущества перед циклом - мы строго ограничиваем количество входных аргументов. В то время как в цикле мы манипулируем глоабльным состоянием (впрочем нам ничто не мешает использовать глобальные переменные в рекурсии). Также у рекурсии есть существенный недостаток. Каждую итерацию рекурсии мы выделяем память на стеке. Вообще говоря эта цена которую мы платим при вызове любой функции. Но при вызове одной функции - мы не заметим разницы. При n вызовах может появиться замедление. Более важный недостаток - то что память на стеке ограничена. То есть во время долгой рекурсии мы в определенный момент мы встретим StackOverflowException. 

Приведу классические примеры рекурсии:

```java
int factorial(int n){
    if(n <= 1)
        return 1;
    else 
        return n*factorial(n-1);
}

int fibonacci(int n){
    if(n <= 2)
        return 1;
    else 
        return fibboacci(n-1) + fibbonacci(n-2);
}
```

Обязательная часть рекурсии - условие завершения. Так или иначе одна из веток нашей функции должна достигать возврата конечного значения. И такая ветка должна быть достижима при любых входных данных. 

Разберем примеры: факториал вам может быть известен обычно он записывается как `n!`. Определяется он следующим образом: факториал от 0 и от 1 равен единице. Факториал для n > 1 равен `n*(n-1)!`. Для отрицательных чисел факториал не определен. Все это вполне наглядно отражено в коде.

Пример с числами фибоначи: первые два числа фибоначи равны единице. Остальные равны сумме двух предыдущих. Пример с фибоначи примечателен тем, что это один из самых неэффективных способов определеть n-е число фибоначи. Зато он очень наглядный. Хотя когда мы стараемся сделать эффективный оптимизированный алгоритм - нам зачастую приходится жертвовать наглядностью - главное чтобывесь кошмар алгоритма был скрыт удобным интерфейсом (не торчал наружу).

Вообще рекурсией пользуются в тех алгоритмах, где она удобнее. Удобнее всмысле выразительнее. Например insertion sort или привычная нам сортировка пузырьком удобнее пишется в цикле. Merge sort напротив удобнее писать рекурсией.

###tail recurtion

В ближайшее время это вам не понадобится тем более в java. Но вам должен кто-нибудь об этом рассказать поэтому упомяну вкратце.

Дело в том что в некоторых компиляторах существует оптимизация рекурсии таким образом, чтобы раскручивать рекурсию в итерации. То есть рекурсия станет не дороже обычного цикла по производительности и к тому же такая же безопасная в плане отсутствия переполнения стека. Но не всякую рекурсию можно оптимизировать. Ту которую мы можем оптимизировать называют хвостовой. В ней должны соблюдаться некоторые условия.

Из википедии:

> Хвостовая рекурсия — частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом из функции.

Попробуем понять на примере с факторилом от 3х:

```
fac(3)
3*(fac(2))
3*(2*(fac(1)))
3*(2*(1))
3*(2)
6
```

Здесь скобки указывают на глубину вложенности функций. Впервые конечное значение возвращается в `fac(1)`. Компилятор не может оптимизировать нашу функцию в цикл так как после вызова себя будет производиться дальнейшие операции (в частности умножение). Приведу более наглядный пример функции с нехвостовой рекурсией:

```java
int factorial(int n){
    if(n <= 1)
        return 1;
    else{ 
        int result = n*factorial(n-1);
        System.out.printl("factorial of " + n + " is: " + result);
        return result;
    }
}
```

Здесь нам более очевидно, что после вызова себя происходят дополнительные операции. 

Как спроектировать функцию так, чтобы она соответствовала требованиям хвостовой рекурсии? Необходимо передавать результирующую переменную в качестве аргумента функции:

```java
int factorial(int n){
    return factorial_iter(n,1);
}

int factorial_iter(int n, int result){
    if(n <= 1)
        return result;
    else 
        return factorial_iter(n-1, n*result);
}
```

Мы переписали нашу функцию таким образом, что после операция - вызов функции (себя), а операция умножения производится в аргументе функции. Но при этом пользователю нашей функции пришлось бы вторым аргументом передавать единицу для корректности работы функции. А это во-первых выглядит некрасиво и во-вторых странно(нам очевидно при домножении на единицу ничего критического не произойдёт, но пользователь никак сразу не поймёт предназначение второго аргумента). Поэтому мы делаем вспомагательную функцию, которая запускает рекурсивную с корректными аргументами (рекурсивную переименовали в `factorial_iter` чтобы было понятно, что она не должна вызываться напрямую). Можно переписать ещё красивее воспользовавшись полиморфизмом функций:

```java
int factorial(int n){
    return factorial(n,1);
}

int factorial(int n, int result){
    if(n <= 1)
        return result;
    else 
        return factorial(n-1, n*result);
}
```
Это знание вам может пригодиться в других языках (Scala, C), но насколько я понял java не поддерживает оптимизацию хвостовой рекурсии (никаких выгод при компиляции вы не получите).


#Переменное число параметров

В стандартной библиотеке C существует функция printf. Она предназначеная для вывода с форматированием. В простейшем случае мы можем выводить так `printf("double: %d, int: %i", thedouble, theint);` то есть первый параметр представляет из себя строку-шаблон в которую будут подставляться по порядку последующие параметры.

В java эта идея позаимствована и сейчас вы можете использовать `String.format`. Можно было бы расширить нашу функцию лога, добавив форматирование, но  в интернете статей про то как сделать это форматирование навалом (точнее небольших примеров навалом, а так там много рутинной работы, чтобы в точности повтярить эту функцию).

Давайте для примера сделаем функцию суммирования. Мы можем передавать в функцию массив int-в, а возвращать int - их сумму. 

```java
int sum(int[] array){
    int sum = 0;
    for(int i = 0; i < array.length; ++i){
        sum += array[i];
    }
    return sum;
}

//...вызов функции
int [] a = {5, 7, 3};
sum(a);
//или выразительнее
sum(new int[]{5, 7, 3});
```

Начиная с java 5 стала доступна форма функций с переменным числом параметров. До этого использовали форму как в примере выше. Чтобы воспользоваться этой формой нам необходимо написать аргумент с его типом и после аргумента поставить многоточие. Многоточие говорит о том, что таких аргументовможет быть ноль или больше. В коде мы его можем использовать как массив. Нам ничего не стоит переписать пример выше:

```java
int sum(int array...){
    int sum = 0;
    for(int i = 0; i < array.length; ++i){
        sum += array[i];
    }
    return sum;
}

//...
sum(5, 7, 3);
```

##Пример: нахождение корня числа

Пример взят из книги SICP. Красивый пример построения функции.

Мы можем легко узнать квадрат числа, но вот нахождения его корня не так очевидно. Чтобы найти его решим уравнение `х^2 - а = 0` (при известном а) численными методами. До этого в математике вы решали всё с помощью аналитических преобразований (по-другому это называется символьные методы). Здесь же мы можем решить всё более универсально. Нам не придётся делать преобразований, а просто реализовать уже имеющиеся алгоритмы. Есть конечно и недостатки у этих методов - в замен на универсальность мы получаем погрешность. То есть в результате мы получим число с точностью до определенного знака. 

В нашем случае то, что мы получим число с некоторой малой погрешностью - нас устраивает. Мы будем вычислять корень методо Ньютона. Вот как это делается в общем случае:

1. Сделать начальное предположение Х0.
2. Задать X(k+1) = X(k) - f(X(k))/f'(X(k));
3. Повторять шаг 2, пока не будет достигнута необходимая точность.

Х0 нам необходим в основном в случае если уравнение предполагает несколько корней - тогда мы задаём откуда нам искать. В случае с корнем наверное лучше всегда искать корень от единицы. 

Во втором шаге нам требуется производная от функции. Её тоже можно найти численно, но функция нам известна так что найдём аналитически. 

```
f(x) = x^2 - a
f'(x) = 2*x
X(k+1) = X(k) - f(X(k))/f'(X(k)) = X(k) - (X(k) - a/X(k))/2 = (X(k) + a/(X(K)))/2
```
Больше теории, стоящей за этим методом вы получите на лекциях Устинова.

Также нам требуется выбрать алгоритм по которому мы прекратим искать корень. Можно сравнивать насколько значение отклонилось от предыдущего, либо насколько далеко от желаемого. Учитывая что метод Ньютона быстро сходится и наша задача легко решается (для положительных чисел) второй метод предпочтительнее. Опишем его формально:
```
|f(x)| < e
|x^2 - a| < e
```

Осталось выразить это в коде:

```java
public class Main {

    static double sqrt(double square, double epsilon, double at){
        at = (at + square/at)/2;
        boolean isGoodEnough = Math.abs(at*at - square) < epsilon;
        if(isGoodEnough) return at;
        else return sqrt(square, epsilon, at);
    }

    static double sqrt(double square, double epsilon){
        return sqrt(square, epsilon, square/2);
    }

    static double sqrt(double square){
        return sqrt(square, 0.00001, square/2);
    }

    public static void main(String[] args) {
        System.out.println(sqrt(3)); 
        // => 1.7320508100147274
    }
}

```

Каквы можете видеть "аргументов по умолчнию" в java не предусмотрено и их приходится вручную прописывать пользуясь полиморфизмом.

#Java 8: лямбда функции.

Они же анонимные функции, они же замыкания. Лямбда функция - даёт возможность объявлять функцию прямо там где её необходимо использовать. Не так уж интересно. Но обычно в языках поддерживающих лямбды функция является первородной сущностью. first class citizen. Короче говоря мы можем пользоваться ей как любым другим объектом. Присваивать её, передавать как аргумент и возвращать из функции. Передавать лямбду как аргумент - вот самое интересное для нас сейчас.

Продолжим ознакомление с численными методами. Теперь применим метод попроще (чтобы не знакомиться с численным вычислением производной), но уже для любой функции. [Метод хорд](https://ru.wikipedia.org/wiki/Метод_хорд). 

```java
import java.util.*;
import java.util.function.DoubleUnaryOperator;

public class Main{
  static double findRoot(DoubleUnaryOperator f, double a, double b, double epsilon)
  {
      while(Math.abs(b - a) > epsilon)
      {
          a = b - (b - a) * f.applyAsDouble(b)/(f.applyAsDouble(b) - f.applyAsDouble(a));
          b = a - (a - b) * f.applyAsDouble(a)/(f.applyAsDouble(a) - f.applyAsDouble(b));
      }
      return b;
  }
  
  static double findRoot(DoubleUnaryOperator f)
  {
      return findRoot(f, 1, 2, 0.0001);
  }
  
  
  public static void main(String[] args){
    System.out.println(findRoot((x) -> x*x - 3));
  }
}
```
Всё вышло не так красиво как ожидалось. На объяснение происходящего уйдёт некоторое время, возможно допишу позже. Пока что здесь самое интересное, то как мы передаём функцию корень которой ищем `findRoot((x) -> x*x - 3)`, функция принимает и возвращает double. 

#Задания
Выполнить одно задание на выбор.
Пара заданий сделана с использованием jogl. Порт opengl для java. Чтобы установить его скачайте https://jogamp.org/deployment/jogamp-current/archive/jogamp-all-platforms.7z архив отсюда. Распакуйте его куда-нибудь. Допустим в `C:\jogamp`. Далее установите переменную CLASSPATH (также как вы это делали с PATH) равной
```
".;C:\jogamp\jar\gluegen-rt.jar;C:\jogamp\jar\jogl-all.jar"
```
В вашей IDE также понадобятся некоторые настройки. В IDEA нажмите `ctrl+alt+shift+s` Перейдите на вкладку libraries, далее нажмите `+` там `java` и укажите путь до двух jar-ников которые указаны выше.

##ConsoleCalendar
Самое простое задание.
Необходимо вывести календарик в консоль. В календаре должен отображаться текущий месяц. Текущее число должно быть выделено (например звездочкой).
Первой строкой должно быть название месяца, вторая строка - сокращенные дни недели (mon tue wed). Дальше числа текущего месяца.
Также для выделения выходных и нынешнего дня можно воспользоваться escape-последовательностями, которые позволяют задавать цвета в консоли. Можно сделать с помощью готовой библиотеки http://www.diogonunes.com/work/jcdp/

##FractalCurve
Нарисовать фрактальную вроде http://en.wikipedia.org/wiki/Koch_snowflake (думаю стоит нарисовать треугольник и к каждой из сторон применить рекурсивную функцию) ну или драконий фрактал (это уже посложнее). 

Задача предполагает работу с библиотекой jogl. Библиотека предоставляет интерфейсы для связи OpenGL. Сам по себе OpenGL вам может показаться очень старомодным - вы будете вызывать кучу функций, которые изменяют текущее состояние графического окна. Ни о каком ООП там речи не идёт jogl повторяет функции написанные для языка C. 

В качестве основы можете взять мой код для треугольника Серпинского. Там код в классе Main создаётся окно (JFrame) и на нем отрисовывается GLCanvas (который и есть OpenGL). Также там создаётся анонимный класс для реакции на разные события (перерисовка, изменение размеров окна). В общем в Main можете ничего не трогать.

В классе Shape в методе setup из интересного мы устанавливаем матрицу проекции так, чтобы точка (0,0) была снизу слева, а точка (width, height) сверху справа. По умолчанию точка (0,0) в центре а ширина и высота равна двум. Иногда так удобнее.

В методе render происходит отрисовка.
```java

		gl2.glClear( GL.GL_COLOR_BUFFER_BIT );
		//fill window with white color
		gl2.glClearColor(1,1,1,0);
		// draw a triangle filling the window
```
Сначала мы очищаем экран. и заливаем белым цветом (можно поменять). `gl2.glClearColor(1,1,1,0)` принимает 4 компоненты от 0 до 1: красный, зелёный, синий, альфа (прозрачный). единица - полный свет, 0 - полная темнота.

```java

		gl2.glBegin( GL.GL_TRIANGLES );
			//set the red color
			gl2.glColor3f( 1, 0, 0 );
			//set 2D points 
			gl2.glVertex2f( 0, 0 );
			gl2.glVertex2f( width, 0 );
			gl2.glVertex2f( width / 2, height );
			gl2.glColor3f( 1, 1, 1 );
			fractal(gl2, steps, width/2, height, 0, 0, width);
		gl2.glEnd();
```
Между метода glBegin и glEnd мы передаём методы устанавливающие вершины (вертексы). Так как поставлен флаг GL_TRIANGLES, то opengl будет после каждых трех точек рисовать треугольник. Чтобы задать цвет используйте метод `gl2.glColor3f( 1, 0, 0 );` здесь три компоненты rgb. Можно менять цвет каждой точки, тогда на треугольнике будет градиент. 

Далее вызвается функция fractal где я также вызываю поочереди эти 2 метода gl2.glColor3f и gl2.glVertex2f. 

Этот подход state машины достаточно старомоден, хоть до сих пор и применяется на десктопе, но в opengl 3.0 он признан deprecated. А в opengl 3.1 он удалён. Также новых реализациях opengl (opengl es 2.0 для смартфонов и webgl для браузеров) эти методы удалены. Теперь принято использовать VBO и выводить массивы, заместо вызывов функций. В принципе такой подход кажется логичнее. Но там много всяких мелких сложностей поэтому я даю как пример подход принятый в OpenGL2. Если вас заинтересовал OpenGL то рекомендую посмотреть http://www.opengl-tutorial.org/ (есть перевод на русский) там вполне себе все соверменно, но расчитано на C++. Если вас интересует графика на java - то лучше посмотреть какие-нибудь библиотеки-обертки, нежели чистый OpenGL. Ничем толком не пользовался, но видел, что есть библиотеки для UI (их много и там java занимает уверенные позиции) и библиотеки для игр (там сложнее, но есть).



##Clock
Нарисовать часы.
Потребуется задание с перемножением матриц из предыдущего урока.

##InfixCalculator
Сделать калькулятор парсящий инфиксную запись и считающий результат. Для этого необходимо реализовать shuting-yard algorithm Дейкстры (можно сначала самому подумать - там ничего сверсложного не описывается). В классическом алгоритме описывается работа со стеком - как и в прошлый раз придется использовать массив с сотней ячеек и переменную указывающую на вершину массива.

Допустимые символы (минимум): цифры, + - / * и скобки. Количество пробелов и переносов строк между символами произвольно. Запись типа "34 235" можно считать ошибкой.

**Входные данные**

Строка с выражением в инфиксной форме.

**Выходные данные**

Результат выражения - число

**Пример**
```
> java InfixCalculator "23 + 45 * 8 - (4 + 20)/9"
> 381
```




