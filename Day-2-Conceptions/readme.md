**рассказать про final**
Концепции языка Java
==================


Источники: http://compscicenter.ru/sites/default/files/materials/java2012_intro.pdf http://www.helloworld.ru/texts/comp/lang/java/java/03.htm 

Java c 1991 года - можно считать язык относительно молодым, хотя разработчики старались его сделать как можно консервативнее.
До 2002 года нумерация была 1.0, 1.1 ... 1.4 В 2004 появилась Java 5.0 нумерация изменилась. В Java 5 вошло много изменений - в нашем курсе мы будем в основном ориентироваться на Java 5, хотя на работе вы можете встретить наследумый код который продолжает работать на более ранних версиях.

Виртуальная машина Java
-----------------

Java является высокоуровневым языком. В этом понятии нет ничего нового. Контрпример низкоуровневые языки - ассемблеры. Когда вы пишете на ассемблере вам приходиться постоянно помнить об архитектуре машины (в основном процессора) под которую вы пишете. Ближе к середине прошлого века разработчикам захотелось сделать языки более ориентированные на решение конкретных задач, нежели перемещению байтов между оперативной памятью и регистрами. С этим понятием связано другое - кроссплатформенность. То есть возможность создавать программы под разные платформы не меняя исходный файл. Так появлялись алгол фортран и т.д.

Java является интерпритируемым языком. Контрпример компилируемые языки - си, паскаль. В компилируемом языке после описания программы на заданном языке вам необходимо запустить специальную программу-сборщик (компилятор). Она проверит ваш код на наличие синтаксических ошибок, попытается составить необходимое ей представление (изначально ваш код - одна огромная строка, что во многих случаях неудобно обрабатывать). Дальше компилятор попытается представить программу в виде процессорных команд для целевой архитектуры (зачастую ваша целевая архитектура и архитектура пк за которым вы работаете будут совпадать и скорее всего это будет x86-64). Вот вы получили необходимую программу, например это будет exe файл под windows. Теперь вы сможете её запустить также как запускали компилятор и и команда одна за другой будут исполняться непосредственно процессором.

У интерпритируемых языков в простейшем случае нам достаточно подать наш исходный код на вход программе интепретатору. Она будет считывать программу построчно (ну то есть по  одной функции\выражению оператору) и стараться выполнять сразу же. Не знаю точно, но наверное очень мало интерпретаторов так работает - это очень не эффективно. 
Подход который используется в java - наш исходный код мы подаём компилятору javac (который в составе jdk). Только теперь компилируются не команды процессора, а байт-код промежуточное представление для интерпретатора. Выглядят они одинаково если открыть файл блокнотом, но байт-код не исполняется процессором. Полученный файл мы можем открыть на любом устройстве (со многими оговорками) с помощью утилиты java (которая в составе jre). Утилита начнёт испольнять команды одна за другой.

Получая универсальность мы жертвуем производительностью. В среднем на одну команду байт-кода нам требуется 15-20 процессорных команд. Поэтому на java зачастую сетуют, что она медленная. Начиная с java 1.3 в jre используется Hotspot. Запуская программу на java собирается статистика по использованию участков кода - те участки которые требовательны к ресурсам и запускаются часто, проходятся jit (Just-In-Time) компилятором. Он берет байт-код java и транслирует его в байт-код процессора на котором работает. Получается всего в 2 раза медленне программ на С/C++. Во многих случаях скорость не главный показатель - иначе бы все программирвоали на ассемблере.

Следует отличать jre (java runtime environment) от jdk (java development kit). Первое необходимо чтобы запускать программы на java. Второе чтобы их собирать. Вам пригодится и то и другое. 

###Существуют следующие редакции поставки jdk:

1. Java SE (Standart Edition) - java для настольных приложений (в освном будем использовать её).
2. Java ME (Micro Edition) - для встраиваемых приложений. Можно найти на старых телефонах игры на java.
3. Java EE (Enterprise Edition) - как SE только с набором дополнительных библиотек. 
4. Java Card - урезанная SE для банковских карт (звучит странно да).

Существуют разные реализации java от разных команий Oracle, IBM, HP. Самая популярная от Oracle (которая унаследовала её от Sun), OpenJDK (открытая реализация). Отдельно есть Dalvic для андроид, которая работает немного иначе стандартных реализаций.

Управление памятью
------------------

В java вы будете иметь дело с автоматическим управлением памятью. Изначально языки создавались с ручным управлением - так естественннее. В С/C++ вам придётся выделять память и в нужном месте освобождать её. Если память не освободить и программа закроется, то ничего страшного по сути не произойдёт - операционная система проследит за тем чтобы пометить всю память после вашей программы как свободную. Если программа работает долго и память не высвобождается (это называется утечки памяти) то вскоре её перестанет хватать и ничем хорошим это не закончится. По возможности программист старается освобождать не используемую память. Но тут возникают две ошибки - возможно память нельзя назвать неиспользуемой и где-нибудь мы ей воспользуемся (постараемся прочитать - и получим мусор либо постараемся присвоить) и мы можем случайно второй раз освободить память (удалить объект). Вообще говоря это undefined behavior (неопределенное поведение) но скорей всего вы увидите окошко segmentation fault и ваша программа рухнет.

Есть механизмы чтобы облегчить жизнь c++ программистам - полуавтоматическое управление памятью на основе подсчета ссылок. Конечно мозг в таком случае отключать не приходится - всё равно необходимо знать в какой момент освобождать память (и вообще не всегда можно пользоваться подсчетом ссылок), но зато вы уменьшаете риск всяких непредвиденных ситуаций вроде segmentation fault. 

Итак в java вам не придется думать об управлении памятью. Сборщик мусора (garbage collector) сам найдёт неиспользуемые объекты и удалит. Это одна из причин по которой java выбран в качестве языка для обучения программированию. Ну тут вообще есть два мнения: первый язык должен быть наиболее простым, чтобы объяснить основы, разные алгоритмы и чтобы это не превратилось в скучную рутину. Либо наиболее строгим, чтобы потом программиста уже было не удивить (ведь вам скорей всего придется ещё столкнуться с С++ ассемблером). Мы склонялись скорее ко второму мнению когда остановились на джава (см. ниже строгая статическая типизация), но с управлением памятью вы так и не будете иметь дело. Проблема в том что из популярных языков с ручным управлением памяти есть C/C++. 

С простой и хороший язык, всмысле хорошо подходит под определенный круг задач. Но на нём нет многих высокоуровневых конструкций и вообще вам затруднительно будет писать какие-либо наглядные приложения, также большая проблема что если вы будете искать что-то про си то результаты поиска будут перекрываться с++. С++ язык с большим количеством разных особенностей, язык очень гибкий и позволяет программисту очень многое, что в конечном итоге приносит ему вред. Чтобы пользоваться им в компаниях вводят свои стандарты которые ограничивают программиста (можете почитать например **поискать** google code guide). Также под линуксом и виндоус есть свои особенности компиляторов для обоих языков. Таким образом (суммируя) если студент спросит преподавателя "где ошибка?" - вопрос скорей всего останется без ответа, а преподаватель узнает для себя какую-нибудь новую особенность языка. Вообще говоря здесь в хорошем свете предстаёт паскаль. Правда он вам наверное уже успел\успеет наскучить.

Насчёт самого сборщика мусора - идея совсем не нова. Уже в начале 60х появился язык Lisp в котором необходим сборщик мусора (возможно он появился и ранее). Основной недостаток сборки мусора в уменьшении производительности. Вообще говоря большая часть работы вашей программы будет уходить на работу с памятью. Это как бы дорого обходиться процессору обратиться в оперативную память (на жесткий диск обратить гораздо дольше). Итак в языке с ручным управлением памятью вы запрашиваете операционную системы вам выделить память и запрашиваете её освободить **(подразобраться вот тут. может я и ошибаюсь?)** это идёт относительно долго но быстрее тут никак не получиться. В полуавтоматической организации управления памятью у вас будут накладные расходы на десяток процессорных операций - пустяк по сравнению с обращением к памяти. 

Если у вас сборщик мусора, то изначально у вас есть большая выделенная область памяти затем она заканчивается и запускается сборка мусора. Вся ваша программа в этот момент останавливается сборщик находит все используемые ("живые") объекты - выделяет новую большую область в оперативной памяти равную нынешней либо большую если нынешней не хватает. Перетаскивает живые объекты в новую область и освобождает старую область. Естественно это на порядок дольше чем ручное управление памятью. Это ещё одна причина по которой java называют медленной. Сейчас конечо алгоритмы стали лучше (я описал простейший) но от потери производительности никуда не уйдёшь.

Такое решение также не подходит для систем реального времени. Это очень узкая задача с которой вы возможно так и не столкнётесь. Там требуется от программы выполнение операций за фиксированное время (пускай и долгое, но одинаковые операции выполняются за одинаковое время). Время работы сборщика мусора, как и время в которое начнётся сборка есть случайная величина.

Язык java
-----------
Также следует отличать виртуальную машину java (jre), которая исполняет программы на своём байт-коде, от языка java. Это важно потому что есть множество языков JRuby, Jython, Groovy, Clojure (lisp для java). Среди них в java сообществе набрал некоторую популярность scala (остальные не имеют особого интереса) - похож на java но перенял много идей из функциональных языков вроде ML, Haskell; имеет много новых выразительных конструкций, перегрузку операторов (которой нет в java). Также возможно использовать язык java под другими платформами например .net от майкрософт. Хотя язык java в отрыве от своей платформы не представляет особого интереса. 

Java является структурным языком. Говорят, что когда-то были и другие языки. Вроде был раньше Basic где все писалось подряд и были безусловные переходы (GOTO) заместо процедур. И ещё в нём строки нумеравались 10, 20, 30... Ещё есть ассемблер - тоже не структурный код. Дейкстра в то время писал про то, что от GOTO следует избавиться. 

> За многие годы я утвердился во мнении о том, что квалификация программистов - функция, обратно зависящая от частоты появления операторов goto в их программах. Позже я открыл, почему оператор go to производит такой пагубный эффект, и я убежден в том, что оператор go to должен быть отменен в языках программирования "высокого уровня" (т.е. отовсюду, кроме, возможно, простого машинного кода).

<i>
<div align="right" style="width:100%;margin:0 0 40 0;font-style:italic;">
<a href="http://www.vspu.ac.ru/~chul/dijkstra/goto/goto.htm">
Edsger Wybe Dijkstra

"Go To Statement Considered Harmful"
</a>
</div>
</i>

Java является императивным языком. Контрпример - функциональные языки. В императивных вы имеете дело с изменением состаяния вашей программы. Вы можете вспомнить как в школе на уроках математики вы упрощали выражение, но оно не менялось а оставалось тем же - его можно вернуть в исходное состаяние. В системе уравнений вы находите корни - значения переменных при которых уравнение истинно. При это никакого изменения состояния нет. Иногда вы выполняете преобразования при которых теряется часть корней, но вы выполняете их с оговоркой, что чтобы восстановить новое выражение до предыдущего требуется дополнить каким-то ещё выражением (*как-то так*). То есть в таком случае вы не преобразуете выражаение а вводите новое (которое является частью предыдущего), нахождение корней которого поможет вам найти корни предыдущего **привести пример**. В java если вы пишете (псевдоязык как пример): 

    x = 5
    
Не означает, что в любом месте в программы вы сможете подставить 5 заместо х и программа останется незимененной. Это означает, что в текущем состоянии программы когда интерпретатор доходит до этой строки становится верным, что х = 5. На следующих строках состояние меняется и это утверждение может стать неверным.

    x = x + 5
    
Такое утверждение также корректно для императивных языков программирования: оно означает взять `х` из предыдущего состояния, прибавить к нему пять, записать получившееся значение как `х` и сохранить состояние. Но будь это математическая запись утверждение было бы просто некорректным (`0 = 5` *может где-нибудь в других математиках такое допустимо и даже имеет смысл?*). Вообще с моей стороны некорректно сравнивать математическую нотацию в которой знак `=` обозначает эквивалентность, равенство и в Java `=` обозначает опертор присваивания. Когда-то в языках чтобы не путать делали оператор `:=` или `<-` таким образом видно, что одно другому вообще говоря не равно, и также можно видеть что присваивание работает справа налево. Но в 80х начал набирать популярность язык си, который изменил тенденцию и теперь во многих языках символ равенства обозначает присваивания. В этом нет большого  преступления - программисты понимают что творится в коде, а знак = выглядит компактнее и вроде приятнее.

Здесь я немного залезаю в детали синтаксиса языка. Сейчас вам это не важно - просто хочу сказать что есть ещё языки поддерживающие функциональную парадигму. Где равенство обозначает равенство и программы составляются через композиции функций. Полностью программу составить в функциональном стиле нельзя - нам так или иначе придется взаимодействовать с внешней средой, читать файлы, реагировать на ввод, это потребует изменять состояние программы. Впервые такой подход использовался в лиспе (очень давно), хотя на нём можно полностью программировать императивно, язык не вносит ограничений (как например хаскель, где программиста принуждают). Также язык обладает некоторой лаконичностью и вообще вам стоит с ним ознакомиться. Лучше всего почитать **SICP** на русском.

###Типизация

По поводу сильной\слабой типизации:

> I give the following general definitions for strong and weak typing, at least when used as absolutes: 
> + Strong typing: A type system that I like and feel comfortable with
> + Weak typing: A type system that worries me, or makes me feel uncomfortable

<i>
<div align="right" style="width:100%;margin:0 40 0 0;font-style:italic;">
<a href="http://blogs.perl.org/users/ovid/2010/08/what-to-know-before-debating-type-systems.html">
вычитал в одном блоге (англ.)
</a>
</div>
</i>

Вот небольшой список языков в зависимости от типизации [википедия в качестве пруфа](http://en.wikipedia.org/wiki/Comparison_of_type_systems). На самом деле это спорно таким образом разделять языки. Java иногда может быть динамической. С# может быть статически типизирован, динамически (даже есть ключевое слово dynamic), и может быть вообще небезопасным как C.

|                           | Static (статическая) | Dynamic (динамическая)| None (Безтиповая) |
|:--------------------------|:--------------------:|:---------------------:|:-----------------:|
|**Safe (безопасная)**      |Haskell, Pascal, Java, C#| Lisp, SmallTalk, Python, Ruby | Assembly |
|**Unsafe (небезопасная)**  | C, C++ | Objective-C | Brainfuck |

Safe/Unsafe - язык является безопасным если гарантируется, что по указанной ссылке лежит объект указанного типа. Во многих языках есть исключение NULL - но об этом позже. C - не безопасен, т.к. этого требует прямое управление памятью. *пруфа нет. пока что это моё личное мнение*

Static/Dynamic - Тут все проще. Язык статический если все типы известны на момент компиляции и динамический если типы известны только в момент исполнения. Java статически-типизированный язык, что значит что вы больше застрахованы от ошибки типов (то есть все такие ошибки выявятся ещё до запуска программы). Многие считают, что статически типизированные языки излишне многословны за счёт того, что каждой переменной приходится указывать тип. Но в последнее время всё большую популярность набирает автоматический вывод типов. Он уже появился в C# (давно) недавно появился в Java 8.

Вообще в ML-языках типизация заметно круче, чем где-либо ещё. Но это никакой метрикой не измеришь. Сейчас вот Mozilla готовит свой язык rust который реализует ML-подобную систему типов. По-другому это и не назовёшь. В среде java есть Scala которая тоже перенимает идеи оттуда.

###ООП
*далее краткий пересказ первой главы эккеля* [для подробной информации см. первоисточник](http://wikijava.org.ua/index.php?title=%D0%93%D0%BB%D0%B0%D0%B2%D0%B0_1_Thinking_in_Java_4th_edition)

Итак мы подошли к самой сути. 

Подобно тому как во многих языках при желании можно писать функционально, также можно писать и объектно (одно другому не противоречит просто пример). Во многих (в большинстве) современных языках есть встроенные конструкции которые представляют данные как объекты. 

Для начала вы можете представлять объект на бытовом уровне. Ну например микроволновка. У объекта есть свойства - там цвет, объём. Вообще говоря цвет может поменяться если мы например испачкаем её. Так что в общем случае будем говорить не свойство, а состояние. Более наглядный пример состояния микроволновки - температура пищи которая в ней подогревается - такое состояние нам неизвестно наверняка мы можем о нём только догадываться - назовём его скрытым (`private`) состоянием. Также есть состояние доступное нам (`public`) - время на таймере готовки. Мы можем воздействовать на таймер. Но не напрямую, а через доступные нам действия (в дальнейшем method). Итак мы крутим *барабан* крутилку которая каждый раз прибавляет время на фиксированное значение. Обычно эти штуки похитрее сделаны но пускай так. И вместе с тем мы видим как время прибавляется допустим на 10 секунд и при этом не зависимо от нас (если мы нажали запуск микроволновки). Мы видим как каждую секунду время на таймере убывает (private method).

Теперь ближе к программированию. При объектно-ориентированном подходе мы манипулируем данными не как набором байтов, а как объектами. У объетов имеются поля, часть из которых являются данными (данные в свою очередь это либо примитивное значение число, байт, строка либо другой объект). Другие поля являются методами. К ним можно обратиться с заданными параметрами и они совершат действие. Возможно ещё вернут значение - результат действия. В общем обо всём попозже. И те и другие поля могут быть: приватными (private скрытыми), публичными (public доступные). Скрытые поля-данные являются внутренним состоянием объекта. Скрытые поля методы необходимы для удобства при работе публичным методов. 

###Классы

Чтобы отобразить объекты на статически-типизированный язык требуются классы. Ну то есть нельзя же создавать объекты и потом по ходу дела указывать им какие у них поля и методы (вообще можно, но так делать плохо). У каждой сущности должен быть указан тип. А чтобы описать тип создаваемого объекта требуется описать предварительно класс. В классе мы описываем все поля объекта и что будут делать методы когда их вызовут.  Также существуют поля называемые статическими - это означает, что они общие для всех объектов класса (позже позже). 

Теперь ближе к java. В java хочешь-нехочешь а с ООП придётся иметь дело. Дело в том, что во многих языках программа начинает исполняться с главной функции `main`. А в java нам придётся создавать класс в котором описывать статическое пбуличное поле-метод `main`. Поэтому наш helloworld получился таким запутанным.

Описывая класс - вы описываете новый тип данных. Под него будет отведена своя память (которую несложно посчитать сложив память примитивов и внутренних объектов. Мы можем порождать новые типы у себя в коде и создавать переменные этих типов. Схожесть классов с другими типами данных в том что он определяет память хранимую данными и поведение при обращении к данным.  Вы расширяете язык программирования, добавляя новые типы данных, соответствующие вашим потребностям. Система программирования благосклонна к новым классам и уделяет им точно такое же внимание, как и встроенным типам.

Но как заставить объект выполнять нужные вам действия? Должен существовать механизм передачи запроса к объекту на выполнение некоторого действия — завершения транзакции, рисования на экране и т. д. Каждый объект умеет выполнять только определенный круг запросов. Запросы, которые вы можете посылать объекту, определяются его интерфейсом, причем интерфейс объекта определяется его типом. Простейшим примером может стать электрическая лампочка:

![лампочка](http://wikijava.org.ua/images/1/1b/P0021.png)

```java
 Light lt = new Light();
 lt.on();
```

В данном примере существует тип (класс) с именем Light (лампа), конкретный объект типа Light с именем It, и класс поддерживает различные запросы к объекту Light: выключить лампочку, включить, сделать ярче или притушить. Вы создаете объект Light, определяя «ссылку» на него (It) и вызывая оператор new для создания нового экземпляра этого типа. Чтобы послать сообщение объекту, следует указать имя объекта и связать его с нужным запросом знаком точки. С точки зрения пользователя заранее определенного класса, этого вполне достаточно для того, чтобы оперировать его объектами.

##Скрытая реализация

Программистов полезно разбить на создателей классов (те, кто создает новые типы данных) и программистов-клиентов (потребители классов, использующие типы данных в своих приложениях). Цель вторых — собрать как можно больше классов, чтобы заниматься быстрой разработкой программ. Цель создателя класса — построить класс, открывающий только то, что необходимо программисту-клиенту, и прячущий все остальное. Почему? Программист-клиент не сможет получить доступ к скрытым частям, а значит, создатель классов оставляет за собой возможность произвольно их изменять, не опасаясь, что это кому-то повредит. «Потаенная» часть обычно и самая «хрупкая» часть объекта, которую легко может испортить неосторожный или несведущий программист-клиент, поэтому сокрытие реализации сокращает количество ошибок в программах.

Безопасность не в том плане, что важно чтобы программист ничего плохого не наделал с классом, а скорее предоставить открытые методы для взаимодействия с классом, чтобы сторонний программист знал как можно использовать класс. При проектировании вашего класса полезно было бы первым делом скрыть от клиента все поля вашего класса, и дать возможность воздействовать на них посредством методов. То есть состояние лампочки можно представить через переменную типа boolean. А доступ к ней предоставить, через метод toggle(). Который меняет состояние.

Вторая причина появления ограничения доступа — стремление позволить разработчику библиотеки изменить внутренние механизмы класса, не беспокоясь о том, как это отразится на программисте-клиенте. Например, вы можете реализовать определенный класс «на скорую руку», чтобы ускорить разработку программы, а затем переписать его, чтобы повысить скорость работы. Если вы правильно разделили и защитили интерфейс и реализацию, сделать это будет совсем несложно. 

Java использует три явных ключевых слова, характеризующих уровень доступа: public, private и protected. Их предназначение и употребление очень просты. Эти спецификаторы доступа определяют, кто имеет право использовать следующие за ними определения. Слово public означает, что последующие определения доступны всем. Наоборот, слово private значит, что следующие за ним предложения доступны только создателю типа, внутри его методов. Термин private — «крепостная стена» между вами и программистом-клиентом. Если кто-то попытается использовать private-члены, он будет остановлен ошибкой компиляции. Спецификатор protected действует схоже с private, за одним исключением — производные классы имеют доступ к членам, помеченным protected, но не имеют доступа к private-членам (наследование мы вскоре рассмотрим). 

В Java также есть доступ «по умолчанию», используемый при отсутствии какого-либо из перечисленных спецификаторов. Он также иногда называется доступом в пределах пакета (package access), поскольку классы могут использовать дружественные члены других классов из своего пакета, но за его пределами те же дружественные члены приобретают статус private.

##Повторное использование реализации
Созданный и протестированный класс должен (в идеале) представлять собой полезный блок кода. Однако оказывается, что добиться этой цели гораздо труднее, чем многие полагают; для разработки повторно используемых объектов требуется опыт и понимание сути дела. Но как только у вас получится хорошая конструкция, она будет просто напрашиваться на внедрение в другие программы. Многократное использование кода — одно из самых впечатляющих преимуществ объектно-ориентированных языков. 

Проще всего использовать класс повторно, непосредственно создавая его объект, но вы можете также поместить объект этого класса внутрь нового класса. Мы называем это внедрением объекта (создание объекта-члена). Новый класс может содержать любое количество объектов других типов, в любом сочетании, которое необходимо для достижения необходимой функциональности. Так как мы составляем новый класс из уже существующих классов, этот способ называется композицией (если композиция выполняется динамически, она обычно именуется агрегацией). Композицию часто называют отношением типа «имеет» (has-a), как, например, в предложении «У автомобиля есть двигатель».

![агрегирование](http://wikijava.org.ua/images/7/73/P0024.png)

Композиция — очень гибкий инструмент. Объекты-члены вашего нового класса обычно объявляются закрытыми (private), что делает их недоступными для программистов-клиентов, использующих класс. Это позволяет вносить изменения в эти объекты-члены без модификации уже существующего клиентского кода. Вы можете также изменять эти члены во время исполнения программы, чтобы динамически управлять поведением вашей программы. Наследование, описанное ниже, не имеет такой гибкости, так как компилятор накладывает определенные ограничения на классы, созданные с применением наследования.

##Наследование

Сама по себе идея объекта крайне удобна. Объект позволяет совмещать данные и функциональность на концептуальном уровне, то есть вы можете представлять нужное понятие из пространства-задачи вместо того, чтобы его конкретизировать используя диалект машины. Эти концепции и образуют фундаментальные единицы языка программирования, описываемые с помощью ключевого слова class. 

Но согласитесь, было бы обидно создавать какой-то класс, а потом проделывать всю работу заново для похожего класса. Гораздо рациональнее взять готовый класс, «клонировать» его, а затем внести добавления и обновления в полученный клон. Это именно то, что вы получаете в результате наследования, с одним исключением — если изначальный класс (называемый также базовым* классом, суперклассом или родительским классом) изменяется, то все изменения отражаются и на его «клоне» (называемом производным классом, унаследованным классом, подклассом или дочерним классом).

![наследование](http://wikijava.org.ua/images/c/ce/P0025.png)

Тип определяет не только свойства группы объектов; он также связан с другими типами. Два типа могут иметь общие черты и поведение, но различаться количеством характеристик, а также способностью обработать большее число сообщений (или обработать их по-другому). Для выражения этой общности типов при наследовании используется понятие базовых и производных типов. Базовый тип содержит все характеристики и действия, общие для всех типов, производных от него. Вы создаете базовый тип, чтобы представить основу своего представления о каких-то объектах в вашей системе. От базового типа порождаются другие типы, выражающие другие реализации этой сущности. 

Например, машина по переработке мусора сортирует отходы. Базовым типом будет «мусор», и каждая частица мусора имеет вес, стоимость и т. п., и может быть раздроблена, расплавлена или разложена. Отталкиваясь от этого, наследуются более определенные виды мусора, имеющие дополнительные характеристики (бутылка имеет цвет) или черты поведения (алюминиевую банку можно смять, стальная банка притягивается магнитом). Вдобавок, некоторые черты поведения могут различаться (стоимость бумаги зависит от ее типа и состояния). Наследование позволяет составить иерархию типов, описывающую решаемую задачу в контексте ее типов. 

Второй пример — классический пример с геометрическими фигурами. Базовым типом здесь является «фигура», и каждая фигура имеет размер, цвет, расположение и т. п. Каждую фигуру можно нарисовать, стереть, переместить, закрасить и т. д. Далее производятся (наследуются) конкретные разновидности фигур: окружность, квадрат, треугольник и т. п., каждая из которых имеет свои дополнительные характеристики и черты поведения. Например, для некоторых фигур поддерживается операция зеркального отображения. Отдельные черты поведения могут различаться, как в случае вычисления площади фигуры. Иерархия типов воплощает как схожие, так и различные свойства фигур.

![наследование](http://wikijava.org.ua/images/e/e1/P0026.png)

Так как и базовый, и производный классы имеют одинаковый основной интерфейс, должна существовать и реализация для этого интерфейса. Другими словами, где-то должен быть код, выполняемый при получении объектом определенного сообщения. Если вы просто унаследовали класс и больше не предпринимали никаких действий, методы из интерфейса базового класса перейдут в производный класс без изменений. Это значит, что объекты производного класса не только однотипны, но и обладают одинаковым поведением, а при этом само наследование теряет смысл. 

Существует два способа изменения нового класса по сравнению с базовым классом. Первый достаточно очевиден: в производный класс добавляются совершенно новые методы. Они уже не являются частью интерфейса базового класса. Видимо, базовый класс не делал всего, что требовалось в данной задаче, так что вы добавили несколько методов. Впрочем, такой простой и примитивный подход к наследованию иногда оказывается идеальным решением проблемы. Однако надо внимательно рассмотреть то, что базовый класс может также нуждаться в этих добавленных методах. Процесс выявления закономерностей и пересмотра архитектуры является повседневным делом в объектно-ориентированном программировании.

Хотя наследование иногда наводит на мысль, что интерфейс будет дополнен новыми методами (особенно в Java, где наследование обозначается ключевым словом extends, то есть «расширять»), это совсем не обязательно. Второй, более важный способ модификации класса заключается в изменении поведения уже существующих методов базового класса. Это называется переопределением (или замещением) метода.

#Примеры встроенных объектов

Некоторые объекты которые нам понадобятся в ближайшее время. В других языках строки и массивы могут не являться объектами, даже если язык и поддерживает ООП (например C++).

##Массивы

Является базовой структурой данных во многих языках программирования. К этому моменту вы уже должно быть привыкли к нотации обращения к полям массива:

```java
int[] array = new int[10];;
//инициализация массива описана чуть ниже
array[1] = 1; //присваивание n-му полю массива
System.out.println(array[2]); //получаем значение n-го поля также как обычной переменной
```

Индексация массива начинается с нуля. То есть мы не можем обратиться к элементам меньше нуля (очевидно), и последний элемент к которому мы можем обратить это n-1. Размер массива в процессе жизни объекта неизменяем.

Массивы являеются одним из первых объектов с которыми мы познакомились. У всех объектов присуще следующее поведение: объекты можно инициализировать null-м (по умолчания они это и делают). null обозначает, что наш объект никак не инициализирован в памяти и никаких операций над ним совершать нельзя. Другой способ проинициализировать объект - выделить область в памяти. Память выделяется с помощью оператора new. После оператора требуется указать тип под который вы выделяете память. 

```java 
int[] array = new int[10];
```

У массивов в отличии от остальных объектов есть некоторые особенности:

1. Только массивы могут содержать примитивы, остальные классы-контейнеры вроде списков и множеств содержут исключительно объекты.
2. Массивы в java строго типизированны. В информации о типе массива требуется указывать тип переменных которых в нем содержаться. Это особенно актуально для старых версий Java, где не было параметризованных типов. Проверка типов на стадии компиляции не позволит использовать неверный тип или неверно интерпретировать извлекаемый тип.
3. У массивов есть возможность инициализировать переменную другими способами, кроме явного `new`. 

```java
//декларируем нашу переменную-массив
int[] arr;
//а ещё мы можем её декларировать вот так
int arr1[];
//это удобно если вы декларируете не только массив
int a, b, arr2[];
//но в целом такая запись не приветствуется

//инициализируем массив (выделяем память под 10 int-в)
arr = new int[10];
//ещё одна удобная запись для инициализации массива
int[] arr3 = {1, 2, 3, 4, 5};
//или если ваша переменная уже объявлена, но вы хотите воспользоваться такой инициализацией
arr3 = new int[]{2, 3, 4};
//А ещё у массива есть поле length
System.out.println(arr3.length);
```

И массивы, и контейнеры защищены от возможных злоупотреблений. При выходе за границу массива или контейнера происходит исключение RuntimeException, свидетельствующее об ошибке программиста. Что выгодно отличает java от c++, где массив всего лишь указатель и выход за границу не обязательно сопровождается выводом ошибки и может доставить много боли в поиске ошибки. 

Большое отличие java массивов в том, что у массива есть поле `length`. А ещё у вас не возникнет никаких проблем при передаче массива в функцию и возврате из функции (как это бы произошло а C++).

###Многомерные массивы

Создание многомерных массивов в Java не вызывает особых сложностей. Для многомерных массивов примитивных типов каждый вектор заключается в фигурные скобки:

```java
    int[][] a = {
      { 1, 2, 3, },
      { 4, 5, 6, },
    };
```

Массив также может создаваться ключевым словом new. Пример создания трехмерного массива выражением new:

```java
// 3мерный массив с фиксированными размерами каждого подмассива.
int[][][] a = new int[2][2][4];
// => [[[0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0]]]
```

То что может вас сильно удивить - это, то что размер массива никак не декларируется в его типе (как это сделано в паскале). То есть компилятор проверяет корректность того, что внутри массива находится массив внутри которого массив, внутри которого массив из `int`. Но размеры их не проверяются. То есть для массива выше мы можем произвести следующую операцию:

```java
a[1][1] = new int[7];
/* => [[[0, 0, 0, 0], 
        [0, 0, 0, 0]], 
       [[0, 0, 0, 0], 
        [0, 0, 0, 0, 0, 0, 0, 0]]] */
```

##Строки

Строки уже больше похожи на обычные объекты, за тем исключением, что они могут быть проинициализированны особой записью и они не изменяемы и у них есть оператор конкатенации.

```java
String str;
char[] c = {'s', 't', 'r'};
//инициализируем с помощью конструктора, как все обычные объекты
str = new String(c);
//инициализирум с помощью особой записи
str = "string";
//есть оператор конкатенации
str = "dat " + str;
//есть его сокрщенная форма
str += "!";
//нет способа обращаться к символам как к ячейкам массива
//но есть много методов в том числе и для обращения к символам
str.charAt(2);
//нет ни одного метода для изменения строки
```

####треш

*жалко удалять. и вроде выставлять на показ стыдно*

Вообще говоря ООП предназначен для построения абстракций в коде, а не для моделирования реального мира. Так что эти примеры не стоит воспринимать всерьёз. Хотя стоит отметить такой момент - почему ООП обзавёлся популряностью. Дело в том что в реальном мире как бы нет объектов. Это наш мозг видит объект. А на самом деле объект в свою очередь абстракция. Не обязательно это называть объектом. Допустим мы видим стул а он состоит из множества частей, которые являются обработанной древисиной, которая является множеством атомов. Итак почему мы видим стул а не древисину. Или можно зайти с другой стороны. Солнечный луч попадает на древесину, теряет часть спектра отражается и попадает нам на глаз. И так много лучей. И они воспринимаются нашими глазами. Дальше там сетчатка, глазной нерв и ещё несколько этапов пока оно дойдёт до соображающей части, которая называет себя личностью. Итак мы видим некоторые двухмерные формы, и также мы видим их выпуклость за счет того что смотрим одновременно с двух сторон. И при всей сложности этого мы безоговорочно называем стул стулом. Даже если увидим его на картинке с экрана. Мы уже не видим выпуклости, и с разных углов и даже если перевернут - все равно стул.

![стул](http://upload.wikimedia.org/wikipedia/commons/d/df/Fancy_Chair_Drawing.jpg)

Другой пример анимация вращающаяся девушка. Мы точно видим как она вращается из одной стороны в другую. Но некоторые видят справа налево, другие слева направо. А если подумают об этом постарются отвлечься то её направление меняется. И даже когда понимаешь весь фокус все равно продолжаешь видеть как она вращается в прежнем направлении. Это всё к тому что в мозгу есть вещь которая заставляет его как можно быстрее принять образ (запомнить, воссоздать его в воображении) и это и есть та самая абстракция которую мы называем объектом. Не все так идеально - можно и отказаться от объектов или сетовать о них что они сделаны неправильно и что классы не нужны. Просто я к тому что они должны восприниматься вами как нечто *естественное*. 

![балерина](http://illuzi.ru/files/images/m_tance_girl.gif)

Вообще эта штука которая принимает образы - она же является и фильтром от инакомыслия. Из-за неё мы не можем принять балерину вращающуюся в обе стороны. 

А ещё маетматики часто строят абстракции которые претендуют на место наивысшей абстракции. Так например монады, множества, категории. Возможно когда-нибудь это окажется полезным для CS.

Все эти соображения не имеют ничего общего с предметом и вообще бессвязны. 
