#Enum

Сразу об этом не было сказано, но enum является полноценным классом. То есть мы можем сделать следующим образом:

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY;
    //здесь мы дальше описываем конструкторы и методы также как в обычном классе

    public boolean isWeekEnd(){
        return this == SATURDAY || this == SUNDAY;
    }
}

//... также используем методы как уобычных объектов
    Day.FRIDAY.isWeekEnd();
```

Выглядит как обычный класс с тем исключением, что мы не можем создавать новых его экземпляров с помощью `new`. Тогда как в таком случае пользоваться конструкторами? Мы можем использовать конструкторы только один раз при описании класса Enum. Вот пример из документации http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html

```java
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6), // здесь происходит вызов конструктора
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
```

Также можно описывать несколько разных конструкторов.

Ещё одна характерная деталь - все енумы наследуются от (абстрактного) класса Enum. У которого есть полезные методы `name` `compareTo` `valueOf`. Кроме того все значения енума являются классами, которые наследуются от базового класса (MERCURY и VENUS наследуются от Planet например). Поэтому они поддерживают операции описаные в теле enum. Но вы также можете добавить ещё методов для каждого значения енума. 

```java
enum Direction { 
   UP { 
        public Direction opposite() { return DOWN; } 
   }, 
   DOWN { 
        public Direction opposite() { return UP; } 
   };  
   public abstract Direction opposite(); 
}
```

#Интерфейсы и абстрактные классы.

Рассмотрим далее пример с игрой (лично мне он кажется каким-то близким, понятным, насущным примером взамен примеров с геометрическими фигурами, либо банковскими операциями). Для начала внесём немного разнообразия в иерархию классов.

Игра определенно двумерная с неопределенным жанром - возможно это лабиринт, возможно по этому лабиринту ходят разные существа с которыми можно взаимодействовать. У нас есть персонаж, разные припятствия и ловушки. Сколько бы насыщенной игру не делай - в ней всё равно будет много статики. Объекты которые не изменяют состояния во времени, а только мешают (или не мешают) проходить персонажу. Если это лабиринт то в нём много стен. Также есть текстура пола, есть разные декорации вроде факелов. 

Все они унаследованы от класса Mesh у которого необходимо переопределить `draw()` `move()` и возможно `collisionWith(Mesh mesh)`. У всех статических игровых объектов (здесь не идёт речь про ключевое слово `static`) есть достаточно общий алгоритм работы: при запуске программы считывается игровая карта и все текстуры игровых объектов. Создаются объекты  указанных в карте классов со своей позицией и текстурой. При вызове `draw` объект каждый раз рисуется без изменений по хранящимся координатам. Метод `move` скорее всего ничег не делает, хотя вполне могли бы быть перемещающиеся декорации вроде облаков. 

Чтобы обобщить декорации и припятствия создадим класс `StaticMesh`. Всё чем будут отличаться такие объекты - это текстура (ну и коллизии), которая впрочем может изменяться со временем. Определим метод `getTexture` который будем вызывать в `draw` указывая координаты (впрочем и координаты тоже можно обобщить до `float[] getCoordinates()`). Таким образом классам наследникам придётся переопределить только несколько методов, а основная работа с графической библиотекой уже будет реализована. 

Но как это сделать таким образом, чтобы в draw вызывать функцию, которая ещё не реалзована? Одно из решений - сделать метод заглушку:
```java
public Texture getTexture(){
	return null;
}
```
Но что если программист унаследовав от данного класса забудет переопределить `getTexture()`? Мы получим `NullPointerException`. Можно конечно сделать так чтобы загружалась прозрачная текстура - тогда не будет ошибки, но программа не будет соответствовать требованиям. Другое опасное состояние: что если программист создаст объект класса `StaticMesh`. Такой класс создан для того чтобы обобщить код, но его экземпляр не имеет никакого смысла.

Чтобы отловить подобные ошибки на этапе компиляции существует ключевое слово `abstract`. Оно ставится перед словом `class`. Поставив его мы получаем гарантию, что не будет создан ни один экземпляр данного класса. И во-вторых мы сможем определять методы без реализации. Унаследовавшись от абстрактного класса, программист будет обязан переопределить все методы без реализации. Хотя он может их не реализовывать при наследовании, но тогда он обязан снова сделать такой класс абстрактным.

```java
public abstract class StaticMesh{
	//абстрактные методы также обозначаются ключевым словом
	pubic abstract Texture getTexture();
	//...
}
```

Если подумать, то класс Mesh тоже по сути должен быть абстрактным классом. У него также не должно быть экземпляров и также должны быть реализованы методы. Правда в отличии StaticMesh у обычного `Mesh` должны быть реализованы все методы. Пока что это всё ещё вписывается в концепцию абстрактного класса.

Попробуем усложнить наш простой игровой мир. Допустим нам необходимо добавить разных эффектов в игру как например дождь или немного сложнее - огонь. Для этого обычно используют система частиц у которых спрайтовая анимация. В терминологии возможно я путаюсь. Но например идея имитации огня в том что постоянно возникает множество новых частиц они все возникают в определенной области и используют допустим синюю текстуру затем по замысловатой траектории поднимается вверх и текстура быстро меняется на оранжеву, ярко красную затем затём тёмную и в витоге удаляется. Траектория у частиц постоянно вариируется, но текстуру для анимации можно использовать одну и ту же - в совокупности это будет незаметно. Допустим наша графическая библиотека является достаточно высокоуровневой и предоставляет средства для такой анимации. Всё что вам нужно унаследоваться от предоставленного класса, далее указать в конструкторе текстуру в которой содержится нарезка разных состояний частицы (указать ширину и высоту картинки), далее указать правило по которому движется ваша частица.

Замечательно - теперь вы можете рисовать огонь. Но он не вписывается в общую систему. Ваш класс Engine имеет массив (а лучше список) объектов с типом Mesh, которые он отрисовывает. Ваш огонь уже имеет предка (из вашей графической библиотеки), а в java нельзя унаследоваться от двух классов сразу (наверное единственный или один из немногих языков где это возможно - С++). Пожалуй правильным решением здесь было бы создать класс, унаследованый от `Mesh` и содержащий класс допустим `FireAnimation`, который бы использовал возможности графического движка, а ваш класс им бы управлял и задавал координаты для отрисовки. Но такой возможности может и не быть.

В этом случае бы пришли на помощь интерфейсы. Для определения интерфейсов существует ключевое слово `interface`. Внутри его определения мы можем описывать только определения публичных методов и `final` поля. Наследование интерфейсов осуществляется через ключевое слово `implements` (реализация) и допустимо множественное наследование интерфейсов.

Но здесь пример несколько надуманный и было предложено решение без использования интерфейсов. У интерфейсов совсем другое применение, нежели у абстрактных классов. Интерфейсы представляют собой некоторый протокол по которому могут общаться разные модули вашей программы. Если вы собираетесь написать некоторую обобщенную структуру данных, то вам лучше всего будет описать необходимый минимум операций, которые бы поддерживала данная структура. Проектируя сверху вниз вы можете более ясно отдавать себе отчет в том зачем вы пишете данную иерархию. Вы должны будете сначала описать интерфейс и затем описать классы реализующие его и на этапе компиляции будет проверка - все ли классы реализовали методы.

Но проверка наличия реализации не главное достоинство интерфейсов. Интерфейсы не позволяют описывать изменяемые поля - таким образом изменения состояния объекта, реализующего интерфейс возможно только через вызовы методов, которые определяют допустимые операции. 

Интерфейсы по своей сути являются чистыми типами данных, без особенностей реализации. То есть в идеале вам стоило бы каждый раз у переменной указывать интерфейсный тип. Конечно до фанатизма не стоит доходить, и в большинстве случаев нас устраивает объектный тип. Если вы используете интерфейсные типы то в последствии вы сможете заменить реализацию. Ещё очень важно в аргументах вашей функции указывать наиболее общий тип, таким образом вы сможете добиться гибкости.

```java 
public interface Mesh{
	public void draw();
	public void update();
	public void SetTexture(Texture tex);
	//...
}

public class Engine{
	private Player player;
	private Mesh[] meshes;

	private void init(Mesh mesh){
		//допустим загружаем в память текстурки для фигуры
	}

	public Engine(){
		player = new Player(/*...*/);
		meshes[0] = player;
		//...
		for(int i = 0; i < meshes.length; ++i)
			init(meshes[i]);
	}
}
```

Кстати интерфейсы могут наследоваться друг от друга ключевым словом `extends`. Пример из java.util

```java
public interface Collection<E> extends Iterable<E> {
```


#Контейнеры

До этого для хранения множества объектов мы использовали только массивы. У массивов есть преймущество - константное время обращения к произвольному элементу. И есть недостаток - невозможность расширять массив. Конечно можно создавать например массив в два раза больший скопировать туда изначальный массив и полученный массив присвоить изначальной переменной. Но тут есть два недостатка: если на объект ссылается несколько переменных из разных участков кода, то тут уже ничего не поделать, все не перебиндить (необходим какой-нибудь класс обертка на который бы все ссылались). И второе если мы увеличиваем размер массива (если увличиваем с запасом то ещё нужна переменная хранящая текущую границу элементов), то мы уже пользуемся им как списком. То есть нам нужна удобная обертка, которая позволяла бы использовать массив с добавлением в него элементов без кучи кода с проверками размеров и дополнительными переменными.

Решение: **ArrayList**. Класс содержащий массив, берущий на себя ответственность по эффективному увеличению массива. Реализующий операции `add`, `remove`, `get` и ещё много удобных методов, которых так не хватает в массиве. 

Такой класс называется контейнером - он призван содержать множество объектов. Думаю идея проста и понятна.

Но если бы вы делали самостоятельно - то вам бы пришлось указать тип для массива. *Массив какого типа вы бы создали?* Пожалуй лучшее решение это Object. Так как вы сможете выразить таким образом любой объект, а для примитивов мы можем использовать классы-оболочки. До Java 5 так и делали. Все списки содержали Object. А чтобы извлечь значение из массива приходилось самостоятельно приводить тип к нужному. Без всяких гарантий, что туда не положат неприводимый тип.

##Параметризованные и типизованные контейнеры

К счастью в Java SE5 появились параметризованные типы. И java.utils переписали с их использованием. Хотя мы можешь не параметризовывать контейнеры как это делали раньше, тогда компилятор выдаст предупреждение.

```java
// Простой пример работы с контейнером
// (компилятор выдает предупреждения).
import java.util.*;
 
class Apple {
  private static long counter;
  private final long id = counter++;
  public long id() { return id; }
}
 
class Orange {}	
 
public class ApplesAndOrangesWithoutGenerics {
  public static void main(String[] args) {
    ArrayList apples = new ArrayList();
    for(int i = 0; i < 3; i++)
      apples.add(new Apple());
    // He препятствует добавлению объекта Orange:
    apples.add(new Orange());
    for(int i = 0; i < apples.size(); i++)
      ((Apple)apples.get(i)).id();
      // Объект Orange обнаруживается только во время выполнения
  }
}
```
А теперь перепишем этот пример с использованием параметризованного типа. Параметр типа записывается после типа и указывается в угловых скобках `Тип<параметр1, параметр2>` параметром для типа в java может быть только другой тип. Хотя например в C++ в качестве параметра можно передавать целые числа, что может стать очень мощным инструментом (подробнее читайте Александеску, хотя там всё сложно написано; проще всего будет посмотреть класс ratio из С++11). Значение каждого параметра зависит от реализации класса. Например для списка параметр обозначает тип хранимого объекта. 

```java
import java.util.*;
 
public class ApplesAndOrangesWithGenerics {
  public static void main(String[] args) {
    ArrayList<Apple> apples = new ArrayList<Apple>();
    for(int i = 0; i < 3; i++)
      apples.add(new Apple());
    // Ошибка компиляции:
    // apples.add(new Orange());
    for(int i = 0; i < apples.size(); i++)
      System.out.println(apples.get(i).id());
    // Использование foreach:
    for(Apple c : apples)
      System.out.print(c.id() + " ");
  }
}
```

Механизм параметризации предотвращает занесение объектов неверного типа в контейнер на стадии компиляции. На этот раз компилятор не разрешит поместить объекты Orange в контейнер apples, поэтому вы получите ошибку на стадии компиляции (а не на стадии выполнения). Также обратите внимание на то, что выборка данных из List не требует преобразования типов. Поскольку контейнер знает тип хранящихся в нем элементов, он автоматически выполняет преобразование при вызове get(). Таким образом, параметризация не только позволяет компилятору проверять тип объектов, помещаемых в контейнеры, но и упрощает синтаксис работы с объектами в контейнере.

А ещё в этом примере вы видите новую управляющую конструкцию, которую принято называть **foreach**. Она использует знакомое ключевое слово `for`. Но синтаксис немного другой

```java
for(типПеременной переменная: переменнаяКонтейнер){
	...
}
```

Во многих случаях такой синтаксис гораздо удобнее. Например если нам не важен номер текущей итерации. Важная деталь для конструкции `foreach`: нельзя изменять порядок или удалять элементы внутри конструкции. Иначе случится беда (ошибка может даже не появится сразу). Если это условие выполняется о скорей всего `foreach` вам идеально подходит.
`foreach` можно использовать на всех классах реализующих интерфейс `Iterable` а также на массивах (если честно я не знаю можно ли достать информацию о классе массивов). Так что я мог дать вам эту конструкцию гораздо раньше. Используйте её гораздо чаще - она надежнее и понятнее, чем `for`.

Восходящее преобразование работает с параметризованными контейнерами точно так же, как и с другими типами:

```java
class GrannySmith extends Apple {}
class Gala extends Apple {}
class Fuji extends Apple {}
class Braeburn extends Apple {}
 
public class GenericsAndUpcasting {
  public static void main(String[] args) {
    ArrayList<Apple> apples = new ArrayList<Apple>();
    apples.add(new GrannySmith());
    apples.add(new Gala());
    apples.add(new Fuji());
    apples.add(new Braeburn());
    for(Apple c : apples)
      System.out.println(c);
  }
}
```

Пока что тему работы с generic-ми (название на английском говорит что классы являются обобщенными) не будем особо затрагивать, так как она достаточно объемная. Но всё же приведу пример создания обобщенного класса. Класс `Box` хранит в себе одну переменную обобщенного типа и обспечивает доступ к ней через методы `get` и `set`.

```java
public class Box<T> {
    // Далее Т будет обозначать обобщенный тип который укажет пользователь
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}

//...
Box<Integer> integerBox = new Box<Integer>();
```

Важно понимать, что в данном примере T может быть любым (но все же объектным) типом. То есть мы можем использовать методы такие же как у Object потому как заранее не знаем какие типы укажет пользователь класса. Хотя есть возможность *уточнить* тип T.

##List

У каждого контейнера в java есть свой интерфейс. Всего их (актуальных) не так много `List`, `Map`, `Queue`, `Set`. И то что устарело и то чего я не знаю. В идеале в типе списка вы должны указывать интерфейс `List` - там должно хватать всё что вам нужно. Кстати восходящее преобразование для параметризванных типов сработает: `ArrayList<T>` будет преобразован до `List<T>`. 
Из плюсов такого подхода: конкретную реализацию списка вы сможете когда она вам понадобится. То есть реализации списков вы выбираете в основном исходя из того сколько операций вставок и сколько обращений к элементам списка вы проводите и если вы найдёте текущую реализацию списка неэффективной вы можете с лёгкостью её заменить. При этом последующий код обращающися к интерфейсу `List` останется актуальным.

```java
List<Apple> apples = new ArrayList<Apple>();
apples = new LinkedList<Apple>();
```

Список поддерживает следующий операции: (не все перечислены, т.к. не все вам пригодятся, если что читайте документацию, например введите в IDEA `List` и нажмите `Ctrl+Q` для документации или `Ctrl+B` для исходного кода, который иногда интереснее документации)
```java
void clear();  // очистить список
E get(int index);  // выдать значение по произвольному индексу
E set(int index, E element); // поставить (заместить) значение по произвольному индексу
void add(E element); // добавить
void add(int index, E element); // добавить по индексу
E remove(int index);  // удалить значение по индексу (возвращает удаленное значение)
int indexOf(Object o); //the index of the first occurrence of the specified element in this list, or -1 if this list does not contain the element
List<E> subList(int fromIndex, int toIndex); // возвращает подсписок от 1го до 2го индекса
```

На самом деле у интерфейса `List` много реализаций. В основном большинство из них узкоспециализированные либо сделаны для работы в многопоточной среде. Для начала нам хватит знания о двух: известный уже `ArrayList` и `LinkedList`.

`LinkedList` представляет из себя двусвязный список. В его реализации есть указатель на начало и на конец. Таким образом операции вставки в начало и конец обходятся нам достаточно дешево. Также им удобно пользоваться если мы проходимся по всем элеметам списка в конструкции `foreach`, но для доступа или добавления элемента в произвольное положение требует O(n) времени, что достаточно дорого в отличии от `ArrayList`.

###Collection

Обобщенный интерфейс для List и Set. Позволяет добавлять `add`, удалять `remove`, преобразовывать в массив `toArray`. А также пройтись итератором (то есть например использовать в `foreach`). 


##Set

Наследуется от интерфейса `Collection` и `Iterable`. Представляет из себя множество объектов. То есть не может содержать повторы. Для начала посмотрим поддерживаемые методы:

```java
boolean contains(Object o); // содержит ли данный объект
boolean add(E e); //возвращает true если такого элемента ещё не было в множестве
boolean remove(Object o); // true если есть в множестве
boolean containsAll(Collection<?> c); // например можно проверить является ли одно множество подмножеством другого
boolean addAll(Collection<? extends E> c);
boolean removeAll(Collection<?> c);
```

Через методы `addAll` и `removeAll` можно сделать объединение множеств или их разницу. Также можно сделать пересечение множеств, хотя это немного сложнее. 

Особенность множеств в том что они не гарантируют порядок ваших элементов.

Для общего предназначения реализованы три класса: `TreeSet`, `HashSet`, `LinkedHashSet`.

В основном используют `HashSet` так, как он гарантирует константное время для поиска элемента в множестве (для этого используются дополнительная память, но нам это скорей всего не важно). Из минусов можно сказать, что `HashSet` совсем не гарантирует порядок элементов. Хотя стоит понимать что зачастую при использовании `Set` он нам не важен.
`LinkedHashSet` - наследуется от `HashSet`. Всё тоже самое, только использует список для сохранения порядка элементов при добавлении их в множество (как у обычного списка).

`TreeSet` - При добавлении элементов создаёт их отсортированый порядок, при этом требует логарифмического времени для добавления и нахождения элемента в дереве.

##Map

Название Map можно перевести на русский как карта и скорей всего вы так себе понимаете это слово. Скорей всего под названием Map понимается "отображение". Чуть позже в курсе матанализа вы узнаете, что функции можно называть отображением. Отображение это то, что устанавливает связь между объектами из первого (ключевого) множества на второе. При этом связь от ключевого множество на множесво данных должна быть однозначной (у одного значения не может быть два ключа), а в обратную сторону такое утверждение уже не работает. 

Например массив типа "Object[]" отображает множество целых чисел на объекты. Строго говоря не всё множество целых чисел (во-первых это технически невозможно int - не бесконечен, а во вторых массив покрывает не весь int зачастую). Тоже самое можно сказать и про списки. 

Интерфейс `Map` предназначен для общего случая. Когда ключом может стать не только целое число, а произвольный объект. Парамтризация типа Map позволяет указать нам тип для ключа и тип для значения:

```java
interface Map<K, V>
```

Здесь K - подразумевает key (ключ) и V - value (значение). Из этого интерфейса вам пригодятся следующие методы:

```java
void clear() 
boolean containsKey(Object k) 
boolean containsValue(Object v)
V get(Object k) // основной метод чтобы получить значение по ключу
Set<K> keySet() // возвращает множество ключей
V put(K k, V v) // основной метод для добавления значений по указаному ключу. если ключ уже есть то его значение заместиться следующим
V remove(Object k)
int size()
Collection<V> values() // возвращает коллкцию из значений
```

Также в `Map` определен метод `entrySet()`, который возвращает множество из объектов класса `Entry`. `Entry` правильнее сказать интерфейс определенный внутри интерфейса `Map`. Вот его методы:

```java
public interface Entry {
	K getKey();
	V getValue();
	V setValue(V value);
}
```

Вот пример его использования:

```java
Map<String, String> map = new HashMap<String, String>();
map.put("1", "a");
map.put("2", "b");
map.put("3", "c");

for(Entry<String, String> entry : map.entrySet())
	if("2".equals(entry.getKey()))
		entry.setValue("x");

System.out.println(map);
// Output: {3=c, 2=x, 1=a}
```

Здесь вы можете заметить, что порядок при добавлении элементов не сохраняется. Об этом подробнее в конкретных реализациях Map. Кстати Map не наследуется от Collection и от Iterable (то есть в `foreach` его не запихать).

Вам пригодятся три класса реализующих интерфейс `Map`: `HashMap`, `TreeMap`, `LinkedHashMap`. Также интерфейс Map содержит устаревшую реализацию Hashtable, которую не рекомендуется использовать.
Поведение и быстродействие HashMap, TreeMap и LinkedHashMap являются аналогами HashSet, TreeSet и LinkedHashSet соответственно: 

* HashMap хранит ключи в хеш-таблице, из-за чего имеет наиболее высокую производительность, но не гарантирует порядок элементов. Может содержать как null-ключи, так и null-значения; 
* TreeMap хранит ключи в отсортированном порядке, из-за чего работает существенно медленнее, чем HashMap. Не может содержать null-ключи, но может содержать null-значения. Сортироваться элементы будут либо в зависимости от реализации интерфейса Comparable, либо используя объект Comparator, который необходимо передать в конструктор TreeMap; 
* LinkedHashMap отличается от HashMap тем, что хранит ключи в порядке их вставки в Map. Эта реализаци Map лишь немного медленнее HashMap. Может содержать как null-ключи, так и null-значения.

##java.util.Collections

Во-первых стоит вспомнить, что существует класс java.util.Arrays. В нём определено много полезных операций над массивами. Он полезен хотя бы потому что массив не может самостоятельно вывести себя. Метод `toString()` выводит совсем не то что хотелось бы. Поэтому стоит использовать `Arrays.toString(a)` или для многомерных `Arrays.deepToString(a)`.

У коллекций такой проблемы нет - у всех достаточно хорошо сделан метод `toString()`. Но дополнительные функции для работы с коллекциями иногда требуются. Метод Collections.addAll() получает объект Collection и либо массив, либо список, разделенный запятыми, и добавляет элементы в Collection. Пример:

```java
// Добавление групп элементов в объекты Collection
import java.util.*;
 
public class AddingGroups {
  public static void main(String[] args) {
    Collection<Integer> collection =
      new ArrayList<Integer>(Arrays.asList(1, 2, 3, 4, 5));
    Integer[] moreInts = { 6, 7, 8, 9, 10 };
    collection.addAll(Arrays.asList(moreInts));
    // Работает намного быстрее, но таким способом 
    // невозможно сконструировать Collection:
    Collections.addAll(collection, 11, 12, 13, 14, 15);
    Collections.addAll(collection, moreInts);
    // Produces a list "backed by" an array:
    List<Integer> list = Arrays.asList(16, 17, 18, 19, 20);
    list.set(1, 99);// Можно - изменение элемента 
    // list.add(21); // Ошибка времени выполнения - нижележащий 
                    // массив не должен изменяться в размерах
  }
}
```

Кроме того вы найдёте там ещё много полезных методов http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html
Вот некоторые: binarySearch, fill, 	indexOfSubList, sort, swap, copy (лучше чем `Object.clone()`).

#java.io

Пакет java.io предназначен для общего ввода-вывода. Конкретно здесь хотелось бы немного показать работу с файловой системой. Более подробно работа со потоками будет рассмотрена позже, после ознакомления с конструкцией `try{}`.

В нынешней jdk появилась `java.nio` (new io). Она предоставляет новый способ работы с внешними данными, однако новый не значит усовершенствованый, а значит другой более узкоспециализированный. То есть `java.io` не теряет актуальности. 

Для начала нам пригодится класс `java.io.File`. Он предназначен для обхода файловой системы. Здесь `File` имеется ввиду обобщенный файл (то есть в том числе и директория). Чтобы указать с каким файлом или директорией мы собираемся работать мы передаём строку с путём в конструктор `new File("C:/")`. Чтобы начать обход по иерархии файлов мы можем воспользоваться методом `File[] listFiles()`. Либо если нам важны только строки можем воспользовать `String[] list()`. Например:

```java
File file = new File("C:/");
// for each directory in the path array
for(File path: file.listFiles()){
    // prints directory name
    if(path.isDirectory())
    	System.out.println(path);
}
```

Как видите есть методы `isFile` и `isDirectory`. Также мы можем создавать поддиректории через метод `mkdir(String name)`.

Вообще говоря все операции с внешними данными потенциально опасны для вашего кода. У вас может оказаться так, что указанного файла нет, либ отказ в доступе, либо файл был в сети а сеть пропала. Поэтому придуманы Exception-ы - ошибки времени исполнения, которые можно отловить и принять нужные меры. В нашем случае мы будем говорить что с кодом всё в порядке а в случае чего пускай ошибка остановит программу и выскочит в консоль:

```java
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class CopyCharacters {
//обратите внимание что мы пробрасываем эксепшон а уровень выше через слово throw
	public static void main(String[] args) throws IOException {

        FileReader inputStream = new FileReader("xanadu.txt");;
        FileWriter outputStream = new FileWriter("characteroutput.txt");
        int c = inputStream.read();
        // -1 обозначает конец файла
        while (c != -1) {
            c = inputStream.read();
            outputStream.write(c);
        }
        inputStream.close();
        outputStream.close();
    }
}
```

В данном примере показывается посимвольная обработка файла. Пример взят [отсюда](http://docs.oracle.com/javase/tutorial/essential/io/charstreams.html). FileReader считывает посимвольно методом read. А FileWriter записывает методом write.
Разумеется у меня таких файлов не оказалось и при запуске я получил "Exception in thread "main" java.io.FileNotFoundException: xanadu.txt (Не удается найти указанный файл)". Вообще конечно плохо не обрабатывать IOException особенно если у вас будет много функций у каждой придётся приписывать  throws IOException 

В ваших домашних работах писать посимвольно будет наверное как-то неудобно, поэтому построчный обработчик BufferedReader принимающий в конструкторе FileReader. 

```java
public static void main(String[] args) throws IOException {
	inputStream = new BufferedReader(new FileReader("xanadu.txt"));
    outputStream = new PrintWriter(new FileWriter("characteroutput.txt"));

    String l;
    while ((l = inputStream.readLine()) != null) {
        outputStream.println(l);
    }
    inputStream.close();
    outputStream.close();
}
```


#Задания

##List (не обязательно)
Оберните список из предыдущего задания в интерфейс List. [Ссылка](http://docs.oracle.com/javase/7/docs/api/java/util/List.html) на описание интерфейса.

В отличие от LinkedList это будет односвязный (а не двусвязный) список, который заранее не знает своего размера. Проще всего приступить к работе будет следующим образом. В IDEA напишите:
```java
class MyList<E> implements List<E>{

}
```
Нажмите `Alt+Insert` выберите `Implement methods...` (нажмите галочку `Copy JavaDoc` чтобы посмотреть документацию - какое поведение требуется от методов) подтвердите выбор. Обратите внимание на то что от параметризиванного интерфейса мы реализуем параметризированный класс. *Это не обязательно*: мы бы могли написать `class StringList implements List<String>`  и создать тем самом список исключительно из строк. Иногда такое более уместно.

Попытайтесь скопировать то что вы уже написали в своём списке. Будет полезнее (вам) если вы отнаследуетесь от прошлой реализации списка, либо включите её в свой класс как поле объекта. Обратите внимание на то что здесь нет `insert` но есть `public void add(int index, E element)`. Нет `merge` но есть `addAll` и он подразумевает другое поведение при котором не соединяются ссылки а элементы из данной в аргументе коллекции добавляются в ваш список. Нет `find`, но есть `indexOf`. 


##Vector
Реализуйте класс содержащий массив из 3х элементов и представляющий собой 3мерный [вектор](https://ru.wikipedia.org/wiki/Вектор_(математика)). (Отдельное интересное задание n-мерный вектор). 

В java нет перегрузки операторов, поэтому сделаем их методами 
```java
public Vector plus(Vector v); //покоординатное сложение
public Vector minus(Vector v);
public Vector product(Vector v); //векторное произведение !необязательно! https://ru.wikipedia.org/wiki/Векторное_произведение
public double dot(Vector v); //скалярное произведение https://ru.wikipedia.org/wiki/Скалярное_произведение
public double length(); // длина вектора
public double distanceTo(Vector v);
```
Также можно сделать методы getX, getY, getZ.

##Задача Иосифа.
https://ru.wikipedia.org/wiki/Задача_Иосифа_Флавия 

Там уже написаны разные решения. Предлагается использовать первое решение, только на списке. В таком случае индексы и элементы сами сдвигаются - должно получиться достаточно лаконично. Можете посмотреть и другие решения. 

##Карточная игра типа дурака. 
(задача не до конца сформулирована, так что опасайтесь - задание творческое).
Интересней такое было бы делать с GUI, но это делает задачу сложной (во-первых в java нет **простых** gui-фреймворков, а во-вторых карточная игра не тривиальная для построения gui задача). Для начала лучше самая простая версия дурака когда нет всяких переводов. И всего 2 игрока, хотя без переводов 3,4 игрока не так уж сложнее получается. Просто опрашивать одного за другим.

Важно попытаться перенести процесс игры в описание классов.
Suit: Enum (spades diamonds hearts clubs) Масть.  
Значение карты int либо Enum
Оба этих enum (либо инта) содержатся в классе Card)
метод - Можно ли бить одну другой. 

Классы: Карта, Игрок(содержит колоду - список карт), Бот (наследуется от игрока), Крупье - содержит колоду (перетасованные карты), и 4 игрока, один из них реальный.

Крупье (Dealer) раздает карты всем нуждающимся игрокам из колоды.В конструкторе у него вызывается метод shuffle() перемешивающий стандартную колоду. А ещё рандомом выбирает козырную масть. Здесь вам наверное пригодится `java.util.Random`:
```java
Random rand = new Random();
int randomNum = rand.nextInt(maximum);
```

Player (Игрок) - абстрактный класс (методы): 
```java
public final int getCardCount();  
public final Player addCard(Card); //реализованный метод - добавляет карту в список и вызывает onCardAdd. Возвращает себя
public final Player addCards(List<Card>); //
protected final void onCardAdd(card); //предоставляет возможность проанализировать полученые карты и пересортировать их (полезнее для бота чем для реального игрока)
public final Card turn(); //вызывается если нужно ходить (вызывает onTurn())
public final Card turn(Card); // вызывается если нужно отбивать карту
public final Card turn(List<Card>); // вызывается если карта отбита и можно докинуть ещё
//абстрактный метод хода
public Card onTurn(); //необходимо переопределить в реализации
// и ещё 2 onTurn()
```

От него наследуются Bot где прописаны алгоритмы как лучше всего ходить. и RealPlayer, который бы при получении карт уведомлял игрока, а при ходе опрашивал через консоль номер карты которой хочет походить игрок.

Ещё нужен класс Game. В котором написаны только статические методы, либо в main создаётся инстанс себя, после чего вызывается конструктор и череда методов. Нужен генератор колоды (список из всех возможных карт), сформированную колоду передаём крупье: `Dealer dealer = new Dealer(getDeck());` примерно так. Создаём бота и приглашаем игрока. Двух игроков присваиваем поля объекта, обявленые как `Player player1, player2` либо список из игроков. Далее вызываем метод игры где содержится цикл опрашивающий игроков их ходы, крупье - выдачу карт, до тех пока крупье не огласит игру завершенной и объявит победителя. 

Конечно там есть что ещё продумать. Что делать при завершении карт (должен ли крупье за этим смотреть, либо класс Game извне, либо игрок вызывать какие-либо методы). В общем тот кто выберет это задание должен сам пофантазировать и наверное обговорить со мной при желании.
