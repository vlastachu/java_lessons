 
###HelloWorld

По традиции начнём с первой программы, которая приветствует этот мир. Выравнивание не обязательно но так лучше читается.
Для начала создадим файл с названием `HelloWorld.java`.

```java
class HelloWorld {
    public static void main (String args []) {
        System.out.println ("Hello World");
    } 
}
```

Чтобы скомпилировать воспользуемся программой `javac` (расшифровывается как java compiler):

    С:\> javac HelloWorld.Java

Эту команду вы должны ввести в консоль. Те кто пользуются ОС GNU/Linux уже должны были привыкнуть к работе с консолью. Пользователям windows придётся найти программу `cmd.exe`. Далее команды для линукса и винды совпадают. Вы запоминаете куда сохранили файл (лучше для этого создать папку так чтобы путь не содержал кирилицу и пробелы и не был слишком длинным например C:/Users/username/java_projects/). Переходите к этому каталогу через команду `cd "путь к каталогу"` кавычки не обязательны. И уже потом выполнить команду выше. 

Чтобы запустить (другая программа поставляемая вместе с JRE для пользователей java программ): 

    С:\> java HelloWorld

Всё это происходит в консоли. В результате через стандартный вывод в консоли вы должны получить:
    
    Hello World

Здесь стоит немного рассказать почему все это происходит в консоли, хотя это и не имеет отношения к предмету. Дело в том что изначально все программы работали в консоли. Консоль была разной постепенно развивалась. Позже появились пользовательские интерфейсы внутри консоли (например турбо паскаль). Позже полноценный графический интерфейс (GUI). Сейчас в windows возможно пользоваться ОС полностью через GUI. Вы можете подумать, что использование консоли это архаизм. 

Тут вам стоит задуматься о том как программы общаются друг с другом. То есть одна программа посредством операционной системы вызывает другую. Вообще говоря программы могут в реальном использовать общую память слать сообщения через папйпы и сокеты находясь на удалённом расстоянии. Но частый случай когда, одна программа вызвает другую передавая ей параметры и ожидая результата.

Так например происходит в вашей IDE, когда вы нажимаете зелёный треугольник (ну всмысле `F5` run). Разумеется существует множество IDE для java и каждая из них не реализует в себе компилятор java. Компилятором сейчас занимается Oracle. Другая команда в Oracle  занимается IDE Netbeans. Графический интерфейс компилятору в большинстве ни к чему, заместо этого они дают возможность вызывать компилятор передавая через аргументы пути к исходным файлам и возможность указывать различные флаги для оптимизаций, названия выходного файла и прочее. Так вот IDE вызывает команду компиляции и если указано в настройках сразу же запускает вашу программу через `java "classname"`.

Здесь у вас опять может закрасться сомнение - если ваша IDE использует эти команды, то зачем вам их знать? 

 * Во-первых профессия программиста требует широкого кругозора относительно инструментов, которыми вы пользуетесь. Читай - вас будут спрашивать на собеседовании. Хотя нет никто такого не спросит, но если выяснится, что вы не ладите с консолью это как-то не серьезно будет выглядеть.
 * Во-вторых вы возможно будете разрабатывать консольные приложения и уж наверняка будете их использовать в своей программе (см. выше).
 * В-третьих это действительно может оказаться удобней. Сначала это кажется странным, но много разработчиков разворачивают свою среду в консоли. В качестве редактора например гибкий vim. Компилятор, виртуальная машина, git изначально удобно использовать в консоли. Есть множество команд для работы с файлами (поиск, сравнение). В качестве дебага gdb. **Но** в среде java это всё не очень распространено, так что можете особо не заморачиваться.

**Домашнее задание:** проделать всё это дома. То есть создать текстовый файл скопипастить туда код сохранить как `HelloWorld.Java`. Открыть консоль перейти в директорию где вы это сохранили (`cd C:/путь/к/папке`) выполнить команды. Убедиться в корректности и победа.

###Объяснение исходного кода 

В общем программа по сути это последовательность команд. Но последовательность команд сложно запоминать и производить операции на ними. Необходимо это как-то организовывать. Поэтому появились сложные конструкции которые по-началу могут сбивать вас с толку. Итак последовательность команд приндлежит методу. То есть чтобы писать программу нам необходимо описать хотя бы один метод. Все методы в свою очередь принадлежат либо объектам (не наш случай). Либо классу. В таком случае нужно приписать ключевое слово `static`. Можно было бы и без статика, но выглядело бы посложнее. Итого: наш код описывает класс, который содержит статический метод, который выводит строку приветствия.

```java
class HelloWorld {
```

В этой строке использовано зарезервированное слово class. Оно говорит транслятору, что мы собираемся описать новый класс. Имя у этого класса мы выбираем сами в данном случае называем также как и программу (вообще говоря в джаве принято создавать один файл на один класс и называть файл также как и класс). В фигурных скобках следуют блоки кода - в данном случае описывающие наш класс.

```java
public static void main (String args []) {
```

Публичный (сейчас не важно), статический(не важно) метод который возврает ровно ничего (void - пустота). Далее идёт имя метода `main`. А принимает список строк - любая консольная программа принимает некоторое количество флагов, пускай в ней это и не предусмотренно. Тут важно обратить внимание на название метода. Дело в том что любая программа на java (и ещё c/c++/c#) начинается со статического метода с названием `main`. В опциях компилятора такое поведение можно поменять, но оно не слишком стесняет в большинстве случаев, так что можно представить это как строгое правило. 

```java
System.out.println ("Hello World");
```

Вызываем метод стандартного вывода строки `hello world`. То есть в java предусмотрено пространство имён `System` для обращения к операционной системе. У которого предсмотрено подпространство `out` для вывода. В котором есть метод вывода строки в консоль, который принимает любой объект и преобразует в строку. Здесь мы и так передаём строку так что ничего не преобразуется а просто выведется.

Далее закрываем блоки. Заметьте, что ограничиваем блок кода мы при помощи фигурных скобок, а вызываем и объявляем методы при помощи круглых скобок. То есть в последовательности команд имя метода и круглые скобки после него будут означать вызов метода. Метод может принимать несколько параметров, в том числе и 0. В таком случае это бы выглядело как `println()`, но тут стоит учесть, что у метода `println` не предусмотрен вызов с 0 параметров и в таком случае мы увидим ошибку компиляции.

###Числа и арифметические операторы

Наша первая программа может немного взаимодействовать с внешним миром. Было бы нагляднее если бы она принимала данные изменяла их и выводила. Сейчас мы остановимся на изменении (модификации) данных. Начнем с примитивных данных (они названы примитивными в первую очередь потому что все остальные виды данных являются композицией примитивных). В java как и во многих других языках программирования к примитивным типам относятся числа и строки. Со строками все на порядок сложнее, поэтому начнем с чисел. 

Числа в свою очередь могут быть представлены разными типами **тут можно рассказать про машинное представление, про то сколько бит и байт отводится под разные типы**. Пока что будем использовать int когда нам необходимо целое число (частый случай) и float, double когда нам небходимо число с плавающей запятой. Можно сказать, что int представляет множество целых чисел `Z`, а float, double действительные `R`. Но тут есть оговорка, множество натуральных чисел в математике не ограничено. В машине такое сложно выразить и используются ограниченные множества: для int это целые число от -2^31 до 2^31-1. Для float немного посложнее. Вообще говоря рекомендуется использовать в основном double и float когда вам необходимо сэкономить оперативную память. **TODO** http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.2.3 . Float в отличии от int не является монолитным числом, а состоит из двух частей - целая часть (N) от -2^24 до 2^24-1 и мантиса (M) от -126 до 127. Так как в компьютере преобладает двоичная запись чисел и float записывается как N*(2^M). **привести примеры**. Ещё у float и double существуют (по стандарту ANSI/IEEE Standard 754-1985) такие специальные значения как положительный и отрицательный ноль, положительная и отрицательная бесконечность и NaN. NaN (Not a Number) - не число. Возникает во время плохих операций как например деление на ноль.

У некоторых может возникнуть недоумение мол - зачем использовать целые числа в программе если их можно выразить через вещественные? Дело в том, что зачастую вам хватит целых чисел (это не ответ на вопрос конечно). И самое главное - целые числа более оптимизированны в современных процессорах.

Кстати в примере с helloworld вы заместо строки также спокойно можете вывести число, например `0`, `-7`, `11.01`.

В java вы можете использовать привычные вам со школы арифметические операторы, которые принимают числа и возвращают числа. В зависимости от количества операндов операторы делятся на унарные (один операнд), бинарные (2) и тернарные (3). В основном будем иметь дело с бинарными. Из унарных нам пригодится только минус `-`. Здесь есть небольшая путаница, с которой вы встречались раньше но не обращали на это внимание - символ минус относится сразу к двум операторам - унарное отрицание и бинарное вычитание. То есть мы можем записать `-3` подразумевая отрицательное число. И можем записать `5-3`, подразумевая вычитание трех из пяти. 

Можете поэкспериментировать подставляя в helloworld, разные выражения `5  - 7`, `44 * 56`, `5 / 0`.

К слову существуют языки в некоторых принята постфиксная или префиксная нотация для записи арифметических операций. Так проще например для процессора (то есть в конечном итоге все приводится к постфиксной нотации). В языке java используется опять же привычная вам нотация,  которая принята при записи математических выражений (наверное интересно почитать почему люди пришли именно к такой и былили альтернативы). Чтобы отличать её от других её называют инфиксной. То есть в префиксной оператор ставится перед операторами, в постфиксной после, а в инфиксной между. Так вам гораздо привычнее но у такой записи есть некоторые недостатки. Например по строке `* 5 - 3 4` можно однозначно (хотя может не очевидно) сказать, что из трех вычтем четыре и результат помножим на 5. Запись `5 * 3 - 4` на первый взгляд может показаться аналогом предыдущей, но в привычной нам инфиксной записи появляется такая проблема как приорете операторов. Чтобы сделать полностью аналогичную запись нам придётся воспользоваться скобками. 

К счастью в java приоретет операторов в основном совпадает с общепринятым, а нам мозг уже неплохо натренирован, чтобы ориентироваться в инфиксной записи. 

**TODO таблица операторов**

Теперь нам будет полезным сохранить где-нибудь результат вычисления. Это можно сделать с помощью локальных переменных. Например:

```java
int a;
double b = 2.0;
```

int и double это типы данных (уже упомянались выше). java - статически типизированный язык программирования - это значит, что вам каждой переменной придется указывать тип. a и b  - это названия переменных вы сами выбираете их. Называть переменные одной буквой считается плохим тоном, но для примера сойдёт. Обычно вы должны понимать зачем вам нужна та или иная переменная и исходя из этого давать ей тип и имя. 
На второй строке вы видите знак равенства - это обозначает присваивание значения переменной. Теперь до тех пор пока мы не присвоим переменной новое значение - b будет обозначать 2.0.
Вы можете задаться вопросом - какое значение теперь храниться в a. Во многих языках будет неопределенное значение (то есть что угодно). Но в java переменные сами инициализируются нулём. Хотя не стоит на это полагаться - не присваивать значение переменной также является дурным тоном. Лучше лишний раз приписать `= 0`.

Переменные можно присваивать другим переменным и их значения комбинировать в выражениях с помощью операторов.

```java
int a = 0, b = 3, c = -5; //переменные одного типа можно инициализировать через запятую
a = b - c;
b = a*c + 4^2; //^ возведение в степень
с = 17 / 2; // тип целочисленный поэтому и результат округлиться до 8
// вообще говоря тут не происходит округления. Дробная часть просто отбрасывается
```
Символы после `//` и до конца строки компилятором не читаются. Такая конструкция называется однострочный комментарий.

```java
/*
 также комментарии бывают 
 и многострочными
*/
```

###Управляющие конструкции: ветвление

Теперь мы можем делать некоторые операции над входными данными, но для полноценного программирования не хватает одной важной детали: control-flow operators/операторов управления потоком исполнения. Вот после них уже можно более менее жить. 

К таким операторам относятся: конструкции ветвления (if, switch) и конструкции циклов (for, while).

Вводный пример: если вы выполняете целочисленное деление, то есть опасность, что правый операнд равен нуля. В таком случае ваша программа приостановится и не буду углубляться в детали - все печально. Обычно у вас есть некоторое представление чему может быть равна переменная и если возможна ситуация с делением на ноль, стоит её обработать.

```java
int a, b;
//... где-то получаем значения a, b
if (b != 0){
   a = a / b; 
}
```
Всё внимание на ключевое слово `if` - после него в скобках должно стоять *условие*. И после скобок должен быть блок с кодом - подобный тому как блок кода для метода main. Он будет выполнен если выполянется условие  и выполнение кода пойдёт дальше. Если условие не выполняется то блок кода пропускается. Такая конструкция называется ветвлением с одной веткой. 

Что значит условие? Это такое выражение которое принимает результат `boolean` - которое в отличии от численных выражений может принимать два значения `true` (истина) и `false` (ложь). Значение условного выражения мы также можем заключить в переменную соответствующего типа. 

Ещё две детали: во-первых многие примитивные типы могут неявно приводится друг к другу (подробнее позже). По следующему правилу: если число равно нулю то оно приводится к false, в ином случае оно является истинной. 
Во-вторых фигурные скобки писать не обязательно, если выражение всего одно. Такие особенности используются для лаконичности, хотя стоит помнить, что лаконичность в коде не самое главное.

Вернемся к нашему коду с обработкой деления на ноль. У нас есть код, который выполнится при всех значения b за исключением нуля. Далее следует код, который выполнится независимо от значения b, но что если мы хотим также обработать ситуацию при b = 0? Мы могли бы написать после конструкции `if` ещё одну `if(b == 0)`, но гораздо выразительнее выглядит конструкция `if(condition) {...} else {...}`.

```java
if (b != 0){
   a = a / b; 
} 
else {
    System.out.printLn("Error: b = 0.");
}
```
Также выразительно мы можем комбинировать конструкции `if else` между собой, создавай цепочки из условий.

### Циклы

Другой вид управляющих конструкци цикл. Схематично цикл чем-то похож на ветвление, только единственная ветка переходит к предыдущей точке в коде. 

Проще всего выглядит цикл `while`. Вот пример с его использованием:

```java
while(x --> 0){
    System.out.println(x*x);
}
```

*Здесь `-->` может напомнить стрелку которая обозначает стремление. И запись можно прочитать как пока х стремиться к 0 напечатать квадрат x. На самом деле здесь нет никакой магии - это всего лишь комбинация постфиксного декремента и оператора сравнения.*

В общем случае конструкци пишется как `while(/*условие*/){ /*список операторов*/ }`. Как и в случае с `if` список операторов может состоять из одного оператора и фигурные скобки не требуются.

Список операторов может ни разу не выполниться, если условие изначально ложное. Также существует разновидность циклов, где список операторов выполнится хотя бы один раз - цикл с постусловием. Представленый выше while соответственно цикл с предусловием. 

Два этих цикла покрывают все возможные сценарии использования циклов. Однако есть более удобная конструкция, которой вы скорее всего будете пользоваться чаще. Вот его общая форма:

```java
for(/*выражение1*/; /*условие завершения*/; /*выражение2*/){
    /*список выражений*/;
}
```

Его можно без всяких потерь транслировать в цикл `while`:

```java
/*выражение1*/;
while(/*условие завершения*/){
    /*выражение2*/;
    /*список выражений*/;
}
```

Такая запись должна вам полностью объяснить как работает `for`. Но скорее всего вы совсем не поняли *зачем*. Дело в том что очень частый случай, что мы инициализируем переменную (вне цикла), затем в цикле изменяем её значение, например инкрементируем и проверяем её. К примеру выведем первые 10 степеней двойки:

```java
for(int i = 1; i <= 10; i++)
    System.out.println(2**i);
```

Либо если нам требуется вывести степени двойки до заранее неизвестного числа:

```java
for(long i = 2; i <= n; i *= i)
    System.out.println(i);
```

##Задания

В заданиях будут использованы входные параметры программы. Напомню, что параметры находятся в массиве argv. Про массивы будет рассказано позже. Пока что вам достаточно воспользоваться следующей записью:

```java
class MyProgramm {
    public static void main (String args []) {
        //получаем первый параметр и приводим его к целочисленному типу
        int arg1 = Integer.parseInt(args[0]);
        //получаем второй параметр в виде строки\
        string arg2 = args[1];
        ...
```

Так делать слегка небезопасно, так как пользователь может ввести не те параметры, которые вы ожидаете. Но в данном случае это не важно - все параметры будут точно такие как описано в задании. Если возникнут проблемы - задайте параметры жестко в коде `int arg1 = 7; //because 42` сейчас это не самое главное.

###1. а) triangle
Вывести в консоль прямоугольный треугольник высотой n.
На первой строке должны быть 2 символа `|\`. На второй строке тоже самое но между двумя символами пробел. На третьей строке два пробела и так далее до n-1. На n-й строке между символом `|` и `\` n-1 символов `_`.
Можете поимпровизировать и нарисовать треугольник в консоли другими символами/способами.

Входный данные:

n (int) от 2 до 15

Выходные данные:

ASCII-изображение прямоугольного треугольника c катетами равными n (выше условие описано строже).

Пример:

```
> triangle 3
|\
| \
|__\
```
###1. b) chess_field
Вывести в консоль шахматную доску размером n на n. Вообще говоря слово шахматная здесь сбивает с толку. Скорее поле с чередующимися клетками. Первая (верхняя левая) клетка - символ `#` следующая пробел и так далее до n-й клетки. Клетка на следующей строке начинается с противоположного символа относительно предыдущей первой клетки для предыдущей строки (вообщем клетки чередуются слева направо и сверху вниз). Другие символы и декорации на ваше усмотрение.

Входный данные:

n (int) от 1 до 15

Выходные данные:

ASCII-изображение поля с чередующимися клетками размером n на n.

Пример:

(излишние декорации для поля)

```
> chess_field 5
+-----+
|# # #|
| # # |
|# # #|
| # # |
|# # #|
+-----+
```

###2. cubic_solve
4 входных параметра (double) a, b, c, d. Представляют собой коэффициенты в кубическом уравнении:

`a*x^3 + b*x^2 + c*x + d = 0` (здесь `^` знак возведения в степень - в java этот оператор есть, но делает кое-что другое)

Вам необходимо решить данное уравнение. Можно сделать задание частично например решить уравнение для случая, когда все корни вещественные. Не пугайтесь: с комплексными числами в коде вам не придется иметь дело. Да и все что вы узнаете о них это то что они существуют и как они записываются. Если вы используете комплексные числа при решении то значит что-то пошло не так.

Вам потребуется импортировать стандартную библиотеку. То есть следующей строчкой после `package ...` поставить: `import java.lang.Math;`. В ходе решения вам пригодятся следующие функции:

```java
    Math.cos(x);    // косинус от х 
    Math.sin(x);    // синус
    Math.acos(x);   // арккосинус
    Math.signum(x); // sgn - может пригодится, но не обязательно.
    Math.pow(x, y); // возводит число x в степень y
    //если нужен корень кубический то возводим в степень 1.0/3.0 
    Math.sqrt(x);   // квадратный корень. можно обойтись и pow
```

Теперь ищем в википедии решение кубического уравнения. Нам бы подошел численный метод, но вы ещё с ними не сталкивались (возможно столкнемся на ближайшем занятии). Поэтому берем точные методы.

первый: https://ru.wikipedia.org/wiki/Формула_Кардано берем оттуда вычисление констант p, q и Q.

В случае если Q больше или равен 0 то вычисляем альфа и бета и выводим результат в консоль. Важно понимать, что мы не вычисляем `y2 = -(a + b)/2  + i*(a - b)*Math.sqrt(3)/2` а вычисляем до конечных значений а букву i выводим в консоль, т.к. она как бы является нотацией для записи комплексных чисел. 
То есть у вас должно быть в коде что-то вроде `System.out.println(y2_real + " + i*" + y2_imaginary);` 

В случае если Q меньше 0, то читаем вот здесь https://ru.wikipedia.org/wiki/Тригонометрическая_формула_Виета важно понимать, что Q из первой статьи и Q из второй разные. Из второй нам потребуется та часть где S > 0. Ну и возможно если S = 0. На свой страх и риск можете попытаться сделать все случаи из второй статьи. При этом придется погуглить все эти функции Arch, sh. В общем я этим не занимался. 

Вы можете предусмотреть в своей программе кратность корней (то есть случай когда 3 корня равны друг другу или два корня равны). И уведомлять пользователя о количестве корней и не выводить лишних строк в консоль. Для этого вам пригодится случай с Q = 0 и/или S = 0.

Входные данные:

(double) a, b, c, d.
a не равен нулю. Все остальные принимают значения допустимые для double. 

Выходные данные:

(опционально) строка говорящая количество корней

(обязательно) строки с каждым корнем

Пример:

**TODO пример и написать про final**
