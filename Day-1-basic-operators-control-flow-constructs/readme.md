 
###HelloWorld

По традиции начнём с первой программы, которая приветствует этот мир. Выравнивание не обязательно но так лучше читается.
Для начала создадим файл с названием `HelloWorld.java`.

```java
class HelloWorld {
    public static void main (String[] args) {
        System.out.println ("Hello World");
    } 
}
```

Чтобы скомпилировать воспользуемся программой `javac` (расшифровывается как java compiler):

    С:\> javac HelloWorld.Java

Эту команду вы должны ввести в консоль. Те кто пользуются ОС GNU/Linux уже должны были привыкнуть к работе с консолью. Пользователям windows придётся найти программу `cmd.exe`. Далее команды для линукса и винды совпадают. Вы запоминаете куда сохранили файл (лучше для этого создать папку так чтобы путь не содержал кирилицу и пробелы и не был слишком длинным например C:/Users/username/java_projects/). Переходите к этому каталогу через команду `cd "путь к каталогу"` кавычки не обязательны. И уже потом выполнить команду выше. 

Чтобы запустить (другая программа поставляемая вместе с JRE для пользователей java программ): 

    С:\> java HelloWorld

Всё это происходит в консоли. В результате через стандартный вывод в консоли вы должны получить:
    
    Hello World

Здесь стоит немного рассказать почему все это происходит в консоли, хотя это и не имеет отношения к предмету. Дело в том что изначально все программы работали в консоли. 
Консоль была разной постепенно развивалась. Позже появились пользовательские интерфейсы внутри консоли (например турбо паскаль). Позже полноценный графический интерфейс (GUI). Сейчас в windows возможно пользоваться ОС полностью через GUI. 
Вы можете подумать, что использование консоли это архаизм. 

Тут вам стоит задуматься о том как программы общаются друг с другом. То есть одна программа посредством операционной системы вызывает другую. Вообще говоря программы могут в реальном использовать общую память слать сообщения через папйпы и сокеты находясь на удалённом расстоянии. Но частый случай когда, одна программа вызвает другую передавая ей параметры и ожидая результата.

Так например происходит в вашей IDE, когда вы нажимаете зелёный треугольник (ну всмысле `F5` run). Разумеется существует множество IDE для java и каждая из них не реализует в себе компилятор java. Компилятором сейчас занимается Oracle. Другая команда в Oracle  занимается IDE Netbeans. Графический интерфейс компилятору в большинстве ни к чему, заместо этого они дают возможность вызывать компилятор передавая через аргументы пути к исходным файлам и возможность указывать различные флаги для оптимизаций, названия выходного файла и прочее. Так вот IDE вызывает команду компиляции и если указано в настройках сразу же запускает вашу программу через `java "classname"`.

Здесь у вас опять может закрасться сомнение - если ваша IDE использует эти команды, то зачем вам их знать? 

 * Во-первых профессия программиста требует широкого кругозора относительно инструментов, которыми вы пользуетесь. Читай - вас будут спрашивать на собеседовании. Хотя нет никто такого не спросит, но если выяснится, что вы не ладите с консолью это как-то не серьезно будет выглядеть.
 * Во-вторых вы возможно будете разрабатывать консольные приложения и уж наверняка будете их использовать в своей программе (см. выше).
 * В-третьих это действительно может оказаться удобней. Сначала это кажется странным, но много разработчиков разворачивают свою среду в консоли. В качестве редактора например гибкий vim. Компилятор, виртуальная машина, git изначально удобно использовать в консоли. Есть множество команд для работы с файлами (поиск, сравнение). В качестве дебага gdb. **Но** в среде java это всё не очень распространено, так что можете особо не заморачиваться.

**Домашнее задание:** проделать всё это дома. То есть создать текстовый файл скопипастить туда код сохранить как `HelloWorld.Java`. Открыть консоль перейти в директорию где вы это сохранили (`cd C:/путь/к/папке`) выполнить команды. Убедиться в корректности и победа. На всякий случай подробный туториал для [Windows](http://docs.oracle.com/javase/tutorial/getStarted/cupojava/win32.html) и [Unix](http://docs.oracle.com/javase/tutorial/getStarted/cupojava/unix.html).

Во многих туториалах рекомендуется два-три дня поработать в текстовом редакторе прежде чем приступать к IDE. В блокноте вам все покажется совсем грустным так, что рекомедую скачать продвинутые блокноты с подсветкой вроде notepad++ или sublime text (мне больше нравится сублим). Многие новички попросту боятся скомпилировать свой проект вне IDE. В дальнейшем я ещё постараюсь затронуть тему разных утилит для сборки проектов типа ant и maven.

####code style
Код ограниченный фигурными скобками мы будем называть блоком кода. Для блоков кода существует определенные правила по оформлению. Эти правила могут отличаться в зависимости от языка в котором вы пишете и в зависимости от организации в которой работаете (вы можете поискать Oracle java code style или Google java code style). Sun во время разработки java использовала стиль **K&R**. В этом стиле открывающая фигурная скобка находится на той же строке, что и управляющая конструкция (for, if, объявление класса или метода). Внутри фигурных скобок мы делаем отступ. Раньше отступы было принято делать табуляцией (клавишей `tab`), но это имеет некоторые проблемы - каждый реадктор отображает табы как хочет. Поэтому сейчас принято использовать пробелы. В **K&R** используется 4 пробела для отступа. [Oracle рекомендует](http://www.oracle.com/technetwork/java/javase/documentation/codeconventions-136091.html#262) использовать 8 пробелов, но на мой взгляд это многовато. Нынешние редакторы кода (в частности IDEA) сами вставляют нужное количество пробелов при нажатии клавиши `tab`. Нужное количество - можно поставить в настроках редактора, мы оставим стандартные настройки. Закрывающая фигурная скобка должна находится на новой строке после блока кода, на том же уровне что и конструкция с открывающей скобкой (то есть без отступа). Чтобы не путаться вы можете нажать сочетание клавиш чтобы IDEA автоматически переформатировала код в соответствии с тем стилем что задан в настройках. Используйте `Ctrl+Alt+I` чтобы переформатировать выделенный код и `Ctrl+Alt+L` чтобы переформатировать весь файл. 


###Объяснение исходного кода 

В общем программа по сути это последовательность команд. Но последовательность команд сложно запоминать и производить операции на ними. Необходимо это как-то организовывать. Поэтому появились сложные конструкции которые по-началу могут сбивать вас с толку. Итак последовательность команд приндлежит методу. То есть чтобы писать программу нам необходимо описать хотя бы один метод. Все методы в свою очередь принадлежат либо объектам (не наш случай). Либо классу. В таком случае нужно приписать ключевое слово `static`. Можно было бы и без статика, но выглядело бы посложнее. Итого: наш код описывает класс, который содержит статический метод, который выводит строку приветствия.

```java
class HelloWorld {
```

В этой строке использовано зарезервированное слово `class`. Оно говорит транслятору, что мы собираемся описать новый класс. Имя у этого класса мы выбираем сами в данном случае называем также как и программу (вообще говоря в джаве принято создавать один файл на один класс и называть файл также как и класс). В фигурных скобках следуют блоки кода - в данном случае описывающие наш класс.

```java
public static void main (String args []) {
```

Публичный (сейчас не важно), статический(не важно) метод который ничего не возвращает (`void` - пустота). Далее идёт имя метода `main`. А принимает список строк - любая консольная программа принимает некоторое количество флагов, пускай в ней это и не предусмотренно. Тут важно обратить внимание на название метода. Дело в том что любая программа на java (и ещё c/c++/c#) начинается со статического метода с названием `main`. В опциях компилятора такое поведение можно поменять, но оно не слишком стесняет в большинстве случаев, так что можно представить это как строгое правило. 

```java
System.out.println ("Hello World");
```

Вызываем метод стандартного вывода строки `hello world`. То есть в java предусмотрено пространство имён `System` для обращения к операционной системе. У которого предсмотрено подпространство `out` для вывода. В котором есть метод вывода строки в консоль, который принимает любой объект и преобразует в строку. Здесь мы и так передаём строку так что ничего не преобразуется а просто выведется.

Далее закрываем блоки. Заметьте, что ограничиваем блок кода мы при помощи фигурных скобок, а вызываем и объявляем методы при помощи круглых скобок. То есть в последовательности команд имя метода и круглые скобки после него будут означать вызов метода. Метод может принимать несколько параметров, в том числе и 0. В таком случае это бы выглядело как `println()`, но тут стоит учесть, что у метода `println` не предусмотрен вызов с 0 параметров и в таком случае мы увидим ошибку компиляции.

###Пакеты

Пакеты в java предназначены для того чтобы организовать пространства имён. То есть чтобы вы создавая свои классы могли не беспокоиться о том, что название вашего класса может встретиться в какой-нибудь библиотеке которую вы собираетесь использовать. Чтобы использовать классы и функции из определенного пространства имён вам придется импортировать пакет. То есть использовать ключевое слово `import`. Его принято писать в начале файла. Например в вашем задании скорей всего понадобится импортировать пакет `java.math`. Это выглядит следующим образом:
```java
import java.math;
```
Ничего сложного? Дело в том что выше мы написали helloworld без пакета. Это корректно для компилятора, но в целом неправильно. Рекомендуется **всегда** задавать пакет создаваемому классу. Чтобы задать пакет предусмотрено ключевое слово `package`. Для имени пакета также предусмотрена некоторая нотация. В качестве имени пакета принято давать перевернутое доменное имя. То есть наше доменное имя - _progexcenter.ru_. Тогда название пакета будет начинаться с `ru.progexcenter.package1.subpackage2`. Начиная с Java 2 имя пакета принято писать строчными буквами.

Ещё одна формальность которую вам придётся соблюдать - это организация рабочих каталогов. Всмысле папок с кодом. Допустим есть корневая директория `C:/Users/Vasya/myproject` в которой содержится ваш проект. В этой корневой директории у вас допустим содержится риадми и папки `doc` для документации, `bin` для скомпилированных файлов, файлы созданные вашей IDE. А для кода должна быть предусмотрена папка `src` (от выражения source code - исходный код). В ней должна быть иерархия повторяющая структуру пакетов вашего проекта. То есть например `C:/Users/Vasya/myproject/src/ru/progexcenter/package1/subpackage2/HelloWorld.java`. Выглядит утомительно, но думаю со временем привыкнете.

Перепишем наш Helloworld в соответствии с требованиями:

```java
// сначала указывается наш пакет
package ru.progexcenter.lesson1.helloworld;
// далее перечисляем все нужные нам импорты
// в нашей программе мы выводим дату, так что нам потребуется 
// класс java.util.Date
// символ * означает, что мы импортируем все классы из пакета java.util
// это делаем для примера, но вообще так не рекомендуется делать
import java.util.*;
 
public class HelloDate {
    public static void main(String[] args) {
        System.out.print("Привет, сегодня: "); 
        System out println(new Date()); //выводим нынешнюю дату
    }
}
```

Пример структуры каталогов можете посмотреть в прилагающейся папке `src` данного репозитория, где лежат домашние задания. 

##Числа и арифметические операторы

Наша первая программа может немного взаимодействовать с внешним миром. Было бы нагляднее если бы она принимала данные изменяла их и выводила. Сейчас мы остановимся на изменении (модификации) данных. Начнем с примитивных данных (они названы примитивными в первую очередь потому что все остальные виды данных являются композицией примитивных). В java как и во многих других языках программирования к примитивным типам относятся числа и буквы (теже числа по сути) и логическое значение. 

Числа в свою очередь могут быть представлены разными типами. 

|Примитивный тип| 	 Размер, бит| 	 Минимум| 	 Максимум| 	 Тип упаковки |
|:---------------|:-------------:|------------:|------------:|:----------------|
|boolean (логические значения)| 	 —| 	 —| 	 —| 	Boolean |
|char (символьные значения)| 	 16| 	 Unicode 0| 	 Unicode 2^16-1| 	 Character|
|byte (байт)| 	 8| 	 -128| 	 +127| 	 Byte |
|short (короткое целое)| 	 16| 	 -2^15| 	 +2^15-1| 	 Short |
|int (целое)| 	 32| 	 -2^31| 	 +2^31-1| 	 Integer |
|long (длинное целое)| 	 64| 	 -2^63| 	 +2^63-1| 	 Long| 
|float (число с плавающей запятой)| 	 32| 	 IEEE754| 	 IEEE754| 	 Float |
|double (число с повышенной точностью)| 	 64| 	 IEEE754| 	 IEEE754| 	 Double| 
|void (пустое значение)| 	 —| 	 —| 	 —| 	 Void|
 
`void` не занимает места в памяти, а boolean может быть организован в памяти по усмотрению компилятора. В идеале он занимает один бит, но иногда это бывает накладно контролировать один бит. Про упаковку примитивов будет рассказано позже.

Пока что будем использовать int когда нам необходимо целое число (частый случай) и float, double когда нам небходимо число с плавающей запятой. Можно сказать, что int представляет множество целых чисел `Z`, а float, double действительные `R`. Но тут есть оговорка, множество натуральных чисел в математике не ограничено. В машине такое сложно выразить и используются ограниченные множества: для int это целые число от -2^31 до 2^31-1. Для float немного посложнее. Вообще говоря рекомендуется использовать в основном double и float когда вам необходимо сэкономить оперативную память. Float в отличии от int не является монолитным числом, а состоит из двух частей - целая часть (N) от -2^24 до 2^24-1 и мантиса (M) от -126 до 127. Так как в компьютере преобладает двоичная запись чисел и float записывается как N*(2^M). **привести примеры**. Ещё у float и double существуют (по стандарту ANSI/IEEE Standard 754-1985) такие специальные значения как положительный и отрицательный ноль, положительная и отрицательная бесконечность и NaN. NaN (Not a Number) - не число. Возникает во время плохих операций как например деление на ноль.

У некоторых может возникнуть недоумение мол - зачем использовать целые числа в программе если их можно выразить через вещественные? Дело в том, что зачастую вам хватит целых чисел (это не ответ на вопрос конечно). И самое главное - целые числа более оптимизированны в современных процессорах.

Кстати в примере с helloworld вы заместо строки также спокойно можете вывести число, например `0`, `-7`, `11.01`. 

В java вы можете использовать привычные вам со школы арифметические операторы, которые принимают числа и возвращают числа. В зависимости от количества операндов операторы делятся на унарные (один операнд), бинарные (2) и тернарные (3). В основном будем иметь дело с бинарными. Из унарных нам пригодится только минус `-` и `!` (логчиеское отрицание). Здесь есть небольшая путаница, с которой вы встречались раньше но не обращали на это внимание - символ минус относится сразу к двум операторам - унарное отрицание и бинарное вычитание. То есть мы можем записать `-3` подразумевая отрицательное число. И можем записать `5-3`, подразумевая вычитание трех из пяти. 

Можете поэкспериментировать подставляя в helloworld, разные выражения `5  - 7`, `44 * 56`, `5 / 0`.

К слову существуют языки в некоторых принята постфиксная или префиксная нотация для записи арифметических операций. Так проще например для процессора (то есть в конечном итоге все приводится к постфиксной нотации). В языке java используется опять же привычная вам нотация,  которая принята при записи математических выражений (наверное интересно почитать почему люди пришли именно к такой и былили альтернативы). Чтобы отличать её от других её называют инфиксной. То есть в префиксной оператор ставится перед операторами, в постфиксной после, а в инфиксной между. Так вам гораздо привычнее но у такой записи есть некоторые недостатки. Например по строке `* 5 - 3 4` можно однозначно (хотя может не очевидно) сказать, что из трех вычтем четыре и результат помножим на 5. Запись `5 * 3 - 4` на первый взгляд может показаться аналогом предыдущей, но в привычной нам инфиксной записи появляется такая проблема как приорете операторов. Чтобы сделать полностью аналогичную запись нам придётся воспользоваться скобками. 

К счастью в java приоретет операторов в основном совпадает с общепринятым, а нам мозг уже неплохо натренирован, чтобы ориентироваться в инфиксной записи. 

Теперь нам будет полезным сохранить где-нибудь результат вычисления. Это можно сделать с помощью локальных переменных. Например:

```java
int a;
double b = 2.0;
```

int и double это типы данных (уже упомянались выше). java - статически типизированный язык программирования - это значит, что вам каждой переменной придется указывать тип. a и b  - это названия переменных вы сами выбираете их. Называть переменные одной буквой считается плохим тоном, но для примера сойдёт. Обычно вы должны понимать зачем вам нужна та или иная переменная и исходя из этого давать ей тип и имя. 
На второй строке вы видите знак равенства - это обозначает присваивание значения переменной. Теперь до тех пор пока мы не присвоим переменной новое значение - b будет обозначать 2.0.
Вы можете задаться вопросом - какое значение теперь храниться в a. Во многих языках будет неопределенное значение (то есть что угодно). Но в java переменные сами инициализируются нулём. Хотя не стоит на это полагаться - не присваивать значение переменной также является дурным тоном. Лучше лишний раз приписать `= 0`. 

Вы могли заметить выше, что для double я написал `2.0` а не 2. Ещё правильней было бы написать `2.0d`. Дело в том что у каждого примитивного типа есть свой литерал (символы которыми можно представить значение типа в коде). Приведем их примеры а заодно и значение по умолчанию для разных типов.

|Примитивный тип|   Значение по умолчанию|
|:-------------|:----------------------|
|boolean|           false|
|char|              '\u0000'(null)|
|byte|            (byte)0|
|short|           (short)0|
|int|          0|
|long|         0L|
|float|        0.0f|
|double|       0.0d|

Переменные можно присваивать другим переменным и их значения комбинировать в выражениях с помощью операторов.
```java
int a = 0, b = 3, c = -5; //переменные одного типа можно инициализировать через запятую
a = b - c;
b = a*c + 4&2; //& побитовый и
с = 17 / 2; // тип целочисленный поэтому и результат округлиться до 8
// строго говоря тут не происходит округления. Дробная часть просто отбрасывается
```
Символы после `//` и до конца строки компилятором не читаются. Такая конструкция называется однострочный комментарий.
```java
/*
 также комментарии бывают 
 и многострочными
*/
```
Существует специальный вид комментариев для генерации документации (начинается с `/**`):
```java
/**
 *
 */
```

####оператор с присваиванием

Часто случается что нам нужно прибавить 10 к переменной или помножить её на два. Часто такие операции совершаются в циклах (см. ниже). Для этого существует специальная форма оператора `+=` или `-=`. Ниже приведена таблица в которой можно посмотреть наличие формы оператора с присваиванием.

####инкремент и декремент

Ещё один особый случай - когда на требуется увеличить переменную на 1, в таком случае мы используем оператор `++` (или `--` для уменьшения). Для этих операторов существует префиксная и постфиксная форма записи. 

```java
int x = 10;
//следующие записи эквивалентны
x = x + 1;
x += 1;
x++;
++x;
// в чем разница последних двух:
x = 10;
System.out.println(x++); // => 10
System.out.println(++x); // => 12
```

Последние две строки могут вас удивить - дело в том что постфиксный оператор возвращает старое значение переменной и затем инкрементирует. В то время как префиксный работает так как ожидается. Рекомендуется чаще использовать префиксный оператор.

####Таблица бинарных операторов

|оператор|с присваиванием| название| тип|приоретет|
|:------:|:-------------:|:--------|:---|:--:|
|=||присваивание|||
|*|*=|умножение|арифметический|3|
|/|/=|деление|арифметический|3|
|%|%=|остаток от деления|арифметический|3|
|+|+=|сложение|арифметический|4|
|-|-=|вычитание|арифметический|4|
|<<|<<=|сдвиг битов влево|битовый|5|
|>>|>>=|сдвиг битов вправо|битовый|5|
|>||больше|сравнение|6|
|>=||больше или равно|сравнение|6|
|<||меньше|сравнение|6|
|<=||меньше или равно|сравнение|6|
|==||равенство|сравнение|7|
|!=||неравенство|сравнение|7|
|&|&=|поразрядное и|битовый|8|
|^|^=|исключающее или(xor)|битовый|9|
|&#124;|&#124;=|поразрядное или|битовый|10|
|&&||условное и|условный|11|
|&#124;&#124;||условное или|условный|12|

Арифметический операторы принимают числа и возвращают числа. Работают как с целыми так и с вещественными числами. Целочисленное деление отбрасывает дробную часть. Все операторы выглядят знакомо для вас за исключением `%` - делит и возвращает остаток от деления. Битовые операторы принимают и возвращают целые числа. Из курса информатики вам должны быть известны. Операторы сравнения принимают числа и возвращают логическое значение (`boolean`). Логические операторы принимают и возвращают boolean. Также битовые операторы могут быть использованы в качестве логических.

О приорететах. В таблице не записаны постфиксные операторы у которых приоретет 1. И префиксные у которых приоретет 2. У тернарного оператора приоретет 13. и самый большой приоретет у операторов присваивания (=, +=, -=...). Здесь значение приоретет как бы инверсированно. То есть то у чего приоретет 1 будет выполнено в первую очеред и приоретет 14 в последнюю. 

####code style

До этого использовались однобуквенные имена переменных. В примерах эти переменные не несли никакого смысла под собой, но в программах обычно не бывает бессмысленных переменных. Для нормальных переменных предусмотрены правила именования. Смысл переменной мы иногда можем описать одним словом например `int length`, но чаще несколькими (но как можно лаконичнее так чтобы нам не надоедало читать длинные простыни этих имён) для таких переменных предусмотрено следующее правило: первое слово пишется с маленькой буквы, остальные с большой. Таким образом мы можем достаточно легко прочитать название `int currentStackSize`. В то же время для классов принято соблюдать такое же правило, но первая буква - заглавная. 

###Управляющие конструкции: ветвление

Теперь мы можем делать некоторые операции над входными данными, но для полноценного программирования не хватает одной важной детали: control-flow operators/операторов управления потоком исполнения. Вот после них уже можно более менее жить. 

К таким операторам относятся: конструкции ветвления (if, switch) и конструкции циклов (for, while).

Вводный пример: если вы выполняете целочисленное деление, то есть опасность, что правый операнд равен нуля. В таком случае ваша программа приостановится и не буду углубляться в детали - все печально. Обычно у вас есть некоторое представление чему может быть равна переменная и если возможна ситуация с делением на ноль, стоит её обработать.

```java
int a, b;
//... где-то получаем значения a, b
if (b != 0){
   a = a / b; 
}
```
Всё внимание на ключевое слово `if` - после него в скобках должно стоять *условие*. И после скобок должен быть блок с кодом - подобный тому как блок кода для метода main. Он будет выполнен если выполянется условие  и выполнение кода пойдёт дальше. Если условие не выполняется то блок кода пропускается. Такая конструкция называется ветвлением с одной веткой. 

Что значит условие? Это такое выражение которое принимает результат `boolean` - которое в отличии от численных выражений может принимать два значения `true` (истина) и `false` (ложь). Значение условного выражения мы также можем заключить в переменную соответствующего типа. 

Ещё две детали: во-первых многие примитивные типы могут неявно приводится друг к другу (подробнее позже). По следующему правилу: если число равно нулю то оно приводится к false, в ином случае оно является истинной. 
Во-вторых фигурные скобки писать не обязательно, если выражение всего одно. Такие особенности используются для лаконичности, хотя стоит помнить, что лаконичность в коде не самое главное.

Вернемся к нашему коду с обработкой деления на ноль. У нас есть код, который выполнится при всех значения b за исключением нуля. Далее следует код, который выполнится независимо от значения b, но что если мы хотим также обработать ситуацию при b = 0? Мы могли бы написать после конструкции `if` ещё одну `if(b == 0)`, но гораздо выразительнее выглядит конструкция `if(condition) {...} else {...}`.
```java
if (b != 0){
    a = a / b; 
} 
else {
    System.out.printLn("Error: b = 0.");
}
```
Также выразительно мы можем комбинировать конструкции `if else` между собой, создавай цепочки из условий.

###Пример ветвления: решение квадратного уравнения

```java
package ru.progexcenter.example;

import java.lang.*;
/**
 * Application solves square root equation from given coefficients
 */
class SquareRoot{
    public static void main(String[] args){
        //get coefficients from application arguments
        double a = Float.parseFloat(args[0]);
        double b = Float.parseFloat(args[1]);
        double c = Float.parseFloat(args[2]);

        final double discriminant = (b * b) - (4.0d * a * c);
        if (discriminant > 0){
            final double root1 = (-b + Math.sqrt(discriminant)) / (2.0d * a);
            final double root2 = (- b - Math.sqrt(discriminant)) / (2.0d * a);

            System.out.println("The roots are unequal and irrational " + root1 + " and " + root2);
        }
        else if (discriminant == 0){
            final double root = - b / (2.0d * a);
            System.out.println("The roots are equal and rational " + root + " and " + root );
        }
        else if (discriminant < 0){
            System.out.println("The roots are imaginary");
        }
    }
} 
```

###Конструкция switch

```java
   int month = 8;
   String monthString;
   switch (month) {
       case 1:  monthString = "January";
                break;
       case 2:  monthString = "February";
                break;
       case 3:  monthString = "March";
                break;
       case 4:  monthString = "April";
                break;
       case 5:  monthString = "May";
                break;
       case 6:  monthString = "June";
                break;
       case 7:  monthString = "July";
                break;
       case 8:  monthString = "August";
                break;
       case 9:  monthString = "September";
                break;
       case 10: monthString = "October";
                break;
       case 11: monthString = "November";
                break;
       case 12: monthString = "December";
                break;
       default: monthString = "Invalid month";
                break;
   }
   System.out.println(monthString);
```
Конструкция `switch` по сути является многоветочным ветвлением. То есть её можно заменить с помощью множества `if else` будет выглядет не так элегантно. Кроме того switch очень узкоспециализированная конструкция. Мы можем обработать лишь конкретные значения примитива (и только примитива).

###тернарный оператор

Ранее он уже упоминался вскользь. Название "тернарный" означает, что у него три аргумента. Это все равно как сказать бинарный оператор, только операторов с тремя аргументами в джава всего один. Также дела обстоят и во многих других языках, поэтому за ним закрепилось такое название. По сути это такой компактный аналог if-then-else:
```java
int x, y;
...
//подгоняем результат
if(x == 0)
    y = 1;
else
    y = Math.sin(x)/x;
//аналогичная запись
y = x == 0 ? 1 : Math.sin(x)/x;
```
В общем случае оператор записывается следующим образом: `(условие)?(ветка при истине):(ветка при лжи)`. Большое отличие тернарного оператора от if-then-else в том, что мы можем записывать его внутри арифметического (или любого другого) выражения. То есть он может возвращать значение в то время как if только выполняет выражение в блоке кода.

####Отличие & от && в условии

Также выше упоминалось что `&` также может быть использован в логических операциях. Первое что могло броситься вам в глаза это разница в приоретете. Хотя если использовать исключительно & заместо && то разницы не заметите. 

Единственная разница в том что у операторов `&&` и `||` есть особое поведение: они сначала проверяют левую часть и если требуется то проверяют правую. То есть если оператор `&&` получает слева `false` то он однозначно может сказать что конечно значение `false`. Аналогично и для `&&`. Вот примеры использования такого поведения:
```java
//синтетический пример
true || (1/0 == 0); //=>true
true | (1/0 == 0); //=> ошибка
//поднадоевший пример
if(x != 0 && y/x > z)... 
```

Обычно принято использовать `||` и `&&` в условных конструкциях. Оператор `&` может быть использован из соображений производительности, так как занимает одну процессорную команду (в один такт). Но в тоже время он может проиграть по производительности: у оператора `&&` не всегда вычисляется правая сторона.
### Циклы

Другой вид управляющих конструкци цикл. Схематично цикл чем-то похож на ветвление, только единственная ветка переходит к предыдущей точке в коде. 

Проще всего выглядит цикл `while`. Вот пример с его использованием:

```java
while(x --> 0){
    System.out.println(x*x);
}
```

*Здесь `-->` может напомнить стрелку которая обозначает стремление. И запись можно прочитать как пока х стремиться к 0 напечатать квадрат x. На самом деле здесь нет никакой магии - это всего лишь комбинация постфиксного декремента и оператора сравнения.*

В общем случае конструкци пишется как `while(/*условие*/){ /*список операторов*/ }`. Как и в случае с `if` список операторов может состоять из одного оператора и фигурные скобки не требуются.

Список операторов может ни разу не выполниться, если условие изначально ложное. Также существует разновидность циклов, где список операторов выполнится хотя бы один раз - цикл с постусловием. Представленый выше while соответственно цикл с предусловием. 

Два этих цикла покрывают все возможные сценарии использования циклов. Однако есть более удобная конструкция, которой вы скорее всего будете пользоваться чаще. Вот его общая форма:

```java
for(/*выражение1*/; /*условие завершения*/; /*выражение2*/){
    /*список выражений*/;
}
```

Его можно без всяких потерь транслировать в цикл `while`:

```java
/*выражение1*/;
while(/*условие завершения*/){
    /*выражение2*/;
    /*список выражений*/;
}
```

Такая запись должна вам полностью объяснить как работает `for`. Но скорее всего вы совсем не поняли *зачем*. Дело в том что очень частый случай, что мы инициализируем переменную (вне цикла), затем в цикле изменяем её значение, например инкрементируем и проверяем её. К примеру выведем первые 10 степеней двойки:

```java
for(int i = 1; i <= 10; i++)
    System.out.println(2**i);
```

Либо если нам требуется вывести степени двойки до заранее неизвестного числа:

```java
for(long i = 2; i <= n; i *= i)
    System.out.println(i);
```

##Задания

В заданиях будут использованы входные параметры программы. Напомню, что параметры находятся в массиве argv. Про массивы будет рассказано позже. Пока что вам достаточно воспользоваться следующей записью:

```java
class MyProgramm {
    public static void main (String args []) {
        //получаем первый параметр и приводим его к целочисленному типу
        int arg1 = Integer.parseInt(args[0]);
        //получаем второй параметр в виде строки
        string arg2 = args[1];
        ...
```

Так делать слегка небезопасно, так как пользователь может ввести не те параметры, которые вы ожидаете. Но в данном случае это не важно - все параметры будут точно такие как описано в задании. Если возникнут проблемы - задайте параметры жестко в коде `int arg1 = 7; //because 42` сейчас это не самое главное.

###1. а) triangle
Вывести в консоль прямоугольный треугольник высотой n.
На первой строке должны быть 2 символа `|\`. На второй строке тоже самое но между двумя символами пробел. На третьей строке два пробела и так далее до n-1. На n-й строке между символом `|` и `\` n-1 символов `_`.
Можете поимпровизировать и нарисовать треугольник в консоли другими символами/способами.
Чтобы записать в строку `\` символ вам придётся его экранировать. Дело в том, что в java (и очень многих других языках) символ обратной косой черты используется для вывода специальных символов вроде перевода строки `\n` и `\t` табуляции. Что бы вывести просто черту необходимо записать `\\`.

Входный данные:

n (int) от 2 до 15

Выходные данные:

ASCII-изображение прямоугольного треугольника c катетами равными n (выше условие описано строже).

Пример:

```
> triangle 3
|\
| \
|__\
```
[шаблон](https://github.com/vlastachu/java_lessons/tree/master/src/ru/progexcenter/lesson1/triangle)
###1. b) ChessField
Вывести в консоль шахматную доску размером n на n. Вообще говоря слово шахматная здесь сбивает с толку. Скорее поле с чередующимися клетками. Первая (верхняя левая) клетка - символ `#` следующая пробел и так далее до n-й клетки. Клетка на следующей строке начинается с противоположного символа относительно предыдущей первой клетки для предыдущей строки (вообщем клетки чередуются слева направо и сверху вниз). Другие символы и декорации на ваше усмотрение.

Входный данные:

n (int) от 1 до 15

Выходные данные:

ASCII-изображение поля с чередующимися клетками размером n на n.

Пример:

(излишние декорации для поля)

```
> chess_field 5
+-----+
|# # #|
| # # |
|# # #|
| # # |
|# # #|
+-----+
```
[шаблон](https://github.com/vlastachu/java_lessons/tree/master/src/ru/progexcenter/lesson1/chessfield)
###2. CubicSolve
4 входных параметра (double) a, b, c, d. Представляют собой коэффициенты в кубическом уравнении:

`a*x^3 + b*x^2 + c*x + d = 0` (здесь `^` знак возведения в степень - в java этот оператор есть, но делает кое-что другое)

Вам необходимо решить данное уравнение. Можно сделать задание частично например решить уравнение для случая, когда все корни вещественные. Не пугайтесь: с комплексными числами в коде вам не придется иметь дело. Да и все что вы узнаете о них это то что они существуют и как они записываются. Если вы используете комплексные числа при решении то значит что-то пошло не так.

Вам потребуется импортировать стандартную библиотеку. То есть следующей строчкой после `package ...` поставить: `import java.lang.Math;`. В ходе решения вам пригодятся следующие функции:

```java
    Math.cos(x);    // косинус от х 
    Math.sin(x);    // синус
    Math.acos(x);   // арккосинус
    Math.signum(x); // sgn - может пригодится, но не обязательно.
    Math.pow(x, y); // возводит число x в степень y
    //если нужен корень кубический то возводим в степень 1.0/3.0 
    Math.sqrt(x);   // квадратный корень. можно обойтись и pow
```

Теперь ищем в википедии решение кубического уравнения. Нам бы подошел численный метод, но вы ещё с ними не сталкивались (возможно столкнемся на ближайшем занятии). Поэтому берем точные методы.

первый: https://ru.wikipedia.org/wiki/Формула_Кардано берем оттуда вычисление констант p, q и Q.

В случае если Q больше или равен 0 то вычисляем альфа и бета и выводим результат в консоль. Важно понимать, что мы не вычисляем `y2 = -(a + b)/2  + i*(a - b)*Math.sqrt(3)/2` а вычисляем до конечных значений а букву i выводим в консоль, т.к. она как бы является нотацией для записи комплексных чисел. 
То есть у вас должно быть в коде что-то вроде `System.out.println(y2_real + " + i*" + y2_imaginary);` 

В случае если Q меньше 0, то читаем вот здесь https://ru.wikipedia.org/wiki/Тригонометрическая_формула_Виета важно понимать, что Q из первой статьи и Q из второй разные. Из второй нам потребуется та часть где S > 0. Ну и возможно если S = 0. На свой страх и риск можете попытаться сделать все случаи из второй статьи. При этом придется погуглить все эти функции Arch, sh. В общем я этим не занимался. 

Вы можете предусмотреть в своей программе кратность корней (то есть случай когда 3 корня равны друг другу или два корня равны). И уведомлять пользователя о количестве корней и не выводить лишних строк в консоль. Для этого вам пригодится случай с Q = 0 и/или S = 0.

Входные данные:

(double) a, b, c, d.
a не равен нулю. Все остальные принимают значения допустимые для double. 

Выходные данные:

(опционально) строка говорящая количество корней

(обязательно) строки с каждым корнем

Пример:

```
> CubicSolve 4 0 -20 12
3 real roots and 0 imaginary
x1 = -2.6
x2 = 0.68
x3 = 1.66
```
[шаблон](https://github.com/vlastachu/java_lessons/tree/master/src/ru/progexcenter/lesson1/cubicsolve)

(скорей всего у вас будет на порядок точнее вывод).

###3.a. GetBinary
На вход подаётся три числа. Требуется вывести биты первого в определенном диапозоне (см. ниже условия и пример). Здесь вам поможет оператор `>>` который сдвигает биты вправо на n позиций. И оператор `&`.
```java
int x = 10; //1010
x <<= 2; //2 (10 в двоичной системе);
x & 1; //0
```
**Входные данные:** 

(int) x, n1, n2.

**Выходные данные**
Биты числа x начиная с позиции n1 до позиции n2

**Пример:**

```
> GetBinary 117 0 10
0001110101
> GetBinary 117 4 7
111
```
[шаблон](https://github.com/vlastachu/java_lessons/tree/master/src/ru/progexcenter/lesson1/getbinary)
###3.b. GetTemperature

Необходимо вывести таблицу для температуры по цельсию в одном столбце от `fromTemperature` до `toTemperature` c шагом `step`. Во втором столбце вывести температуру по фаренгейту. Перавод расчитывается по формуле `celsius=(5/9)*(fahrenheit-32) fahrenheit=(9/5)*celsius + 32`.

**Входные данные:** 

(int) fromTemperature, toTemperature, step.

**Выходные данные**
Два столбца в первом температура по цельсию (с заданным начало концом и шагом), а во втором соответствующая температура по фаренгейту.

**Пример:**

```
> GetTemperature 0 70 20
Celsius     Fahrenheit
0           32
20          68
40          104
60          140
```
[шаблон](https://github.com/vlastachu/java_lessons/tree/master/src/ru/progexcenter/lesson1/gettemperature)
