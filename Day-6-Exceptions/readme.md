Полезные статьи: [Oracle Tutorial](http://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html) и [хабр](http://habrahabr.ru/company/golovachcourses/blog/223821) [продолжение](http://habrahabr.ru/company/golovachcourses/blog/225585/)

#Exception

Exception (**исключение**) - событие, проявляющееся во время исполнения программы, которое прерывает нормальный поток исполнения операций.

Когда ошибка проявляется внутри метода, метод создаёт объект и отдаёт его системе исполнения. Объект называется *exception object* содержит информацию об ошибке, включая тип ошибки и состояние программы на момент возникновения ошибки. Создание объекта исключения и передача его системе исполнения назыается пробрасывание исключения (throwing an exception).

Когда система исполнения (runtime system) получает исключение - она пытается найти что-то, что могло бы обработать исключение. Она ищет это *что-то* в списке методов, которые были вызваны ранее. То есть на момент вызова исключения мы находимся в методе1, который был вызван методом2, который был вызван методом main, тогда система будет искать обработчик сначала в нашем методе1 и так выше. Такой список методов называется **callstack**.

![иллюстрация]()

Если система исполнения находит подходящий обработчик исключения, то это называется *поймать исключение* (**catch** the exception).

Почему все так устроено? Допустим вы пишете некий метод, принимающий на вход список и допустим рандомно перетасовывающий элементы в нём (что-то вроде карточной игры). Когда, вы принимаете объект извне вы знаете, что он может оказаться равным null. Но зная это что вы предпримете? Наверное правильнее было бы ничего не делать. Но что если это ломает логику программы? В таком случае правльнее бросить NullPointerException и пускай сверху с ним разберуться. То есть с ошибкой мы неможем разобраться прямо в месте её возникновения, т.к. мы не знаем как наш метод используется. В методах вызывающих наш мы сможем обработать ошибку, т.к. обладаем достаточным контекстом ошибки. 

Пример конечно надуманный null почти всегда можно обработать в коде без всяких исключений.

#Создание исключений

Чтобы вызвать исключение нам сначало необходимо создать объект-исключение. Он создаётся точно также как и другие объекты в куче с помощью оператора **new**. У всех стандартных исключений существует как минимум два конструктора: без аргументов и с аргументом строкой: объясняет причину исключения.

Далее нам потребуется непосредственно передать исключение системе обработки: это осуществляется с помощью ключевого слова **throw**.

```java
Exception e = new NullPointerException("list = null; can't shuffle");
throw e; //здесь дальнейшее исполнение метода прерывается
```
Чаще всего исключение создаётся в том же месте в котором и пробрасывается:
```java
throw new NullPointerException("list = null; can't shuffle");
```

Во время вызова исключения происходит *безусловный переход* что-то вроде **return**, но при этом метод не возвращает то значение, которое предусмотрено (по сути он никакого значения не возвращает).

Начиная со слова `throw` появляется некоторая магия вокруг исключений: в качестве аргумента для `throw` мы передаём объект, но не каждый объект может стать претендентом на роль исключения. Чтобы объект можно было *пробросить* он (его класс) должен наследовать класс **Throwable** (странно что не интерфейс). Почему это называют магией? Потому что это как-то *не по правилам* чтоли. Если ключевое слово принимает объект, то наверное любой объект. Дальше будет ещё больше магии.


#Перехват исключений: Конструкция try catch

Ранее уже упоминалось, что при пробросе исключения система ищет подходящий обработчик. Исключения обрабатывает блок **try**

```java
try{
    dangerous1();
    dangerous2();
    dangerous3();
}
```
Точнее сказать он их не обрабатывает а перехватывает. То есть если в одном из выражений (не обязательно методов это может быть и просто `1/0;`)  возникнет исключение, то оно перейдёт к обработчик. Просто так блок `try` не пишется за ним обязательно должен следовать `catch` либо `finally`, либо оба сразу.

##catch

```java
private static void dangerous(){
		throw new RuntimeException();
}

public static void main(String[] args){
	try{
		dangerous();
	}
	catch (Exception e){
		e.printStackTrace();
	}
}

>>  java.lang.RuntimeException
	at com.company.Main.dangerous(Main.java:158)
	at com.company.Main.main(Main.java:163)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
```
Если бы мы не обработали это исключение нас бы ожидал примерно такой же вывод. Зато теперь обработав исключение мы можем работать дальше. Зачастую в случае ловли исключения у нас не остаётся вариантов как продолжать работать. Иногда можно уведомить пользователя например о том что не удаётся открыть файл, мол выбери другой.

Ключевое слово **catch** предназначено для того, чтобы поймать и обработать исключение. `catch` в качестве аргумента принимает также `Throwable` и использует его как аргумент функции. Если никакого исключения не было то блок `catch` не вызовется. Сходство `catch` с функцией в том что к нему будет применен полиморфизм.

Во-первых в этом примере вы можете заметить восходящее преобразование: от RuntimeException до Exception (оба потомки Throwable). Exception является предком для RuntimeException - поэтому преобразование допустимо.

Во-вторых допустимо несколько веток для `catch` (допустим Throwable1 и 2 и 3 унаследованы от Throwable):

```java
try{
    throw new Throwable1();
    throw new Throwable2();
    throw new Throwable3();
}
catch(Throwable3 t){}//допустимо несколько (включая 0) блоков catch
catch(Throwable2 t){}
catch(Throwable1 t){} // <- вызовется этот
```

Что тут происходит? Сначала пробрасывается исключение типа `Throwable1`. Значит остальное исполнение блока `try` прекращается и начинается поиск подходящего обработчика. Cначала находим обработчик для `Throwable3`, но 1 и 3 находятся на разных ветках наследования, поэтому восходящее преобразование недопустимо. Далее ищем другой обработчик - 2 тоже не подходит. и останавливаемся на 3. 

Что будет если убрать строку `catch(Throwable1 t){}`? Обработчик так и не будет найден и исключение проброситься на уровень выше. Возможно во всей программе не будет обработчика тогда программа приостановится.

Что будет если добавить строку `catch(Throwable t){}`? Если мы её добавим в конце то всё относительно хорошо:
```java
try{
    //опасный код
}
catch(Throwable3 t){}
catch(Throwable2 t){}
catch(Throwable1 t){} 
catch(Throwable t){}
```
В итоге возможно 3й 2й или 1й обработчики в зависимости от бросаемого исключения. И если бросается какое-то другое исключение то обязательно исполнится последний обработчик. Если мы поставим его в начало:
```java
try{
    //опасный код
}
catch(Throwable t){}
catch(Throwable3 t){}
catch(Throwable2 t){}
catch(Throwable1 t){} 
```
 То исполнится только первый обработчик. То есть остальные 3 ниже **никогда** не исполнятся. Ваша IDE их вам скорее всего подчеркнет, т.к. они бесполезны. Это происходит потому что поиск подходящего обработчика осуществляется последовательно сверху вниз. А `Throwable` является наиболее общим типом для всех исключений.

##Оператор instanceof

Вас возможно задело то что во время исполнения `catch` может проверить, к какому типу относится объект. Такую магию можно провернуть и в остальном коде не относящемся к исключениям. 

Дело в том что информация о классе объекта, о всей иерархии классов хранится в памяти во время исполнения (в отличии от например от C++ где с этим посложнее). И более того вся эта информация может бывть предоставлена программисту (гуглите reflection).

В более менее простом случае, когда мы откуда то получаем ссылку общего типа и нам необходимо узнать частный то мы можем воспользоваться оператором `instanceof`. 



##Пример Map.find возвращает null







##Checked и Unchecked Exceptions
