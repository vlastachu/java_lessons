Полезные статьи: [Oracle Tutorial](http://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html) и [хабр](http://habrahabr.ru/company/golovachcourses/blog/223821) [продолжение](http://habrahabr.ru/company/golovachcourses/blog/225585/)

#Exception

Exception (**исключение**) - событие, проявляющееся во время исполнения программы, которое прерывает нормальный поток исполнения операций.

Когда ошибка проявляется внутри метода, метод создаёт объект и отдаёт его системе исполнения. Объект называется *exception object* содержит информацию об ошибке, включая тип ошибки и состояние программы на момент возникновения ошибки. Создание объекта исключения и передача его системе исполнения назыается пробрасывание исключения (throwing an exception).

Когда система исполнения (runtime system) получает исключение - она пытается найти что-то, что могло бы обработать исключение. Она ищет это *что-то* в списке методов, которые были вызваны ранее. То есть на момент вызова исключения мы находимся в методе1, который был вызван методом2, который был вызван методом main, тогда система будет искать обработчик сначала в нашем методе1 и так выше. Такой список методов называется **callstack**.

![иллюстрация]()

Если система исполнения находит подходящий обработчик исключения, то это называется *поймать исключение* (**catch** the exception).

Почему все так устроено? Допустим вы пишете некий метод, принимающий на вход список и допустим рандомно перетасовывающий элементы в нём (что-то вроде карточной игры). Когда, вы принимаете объект извне вы знаете, что он может оказаться равным null. Но зная это что вы предпримете? Наверное правильнее было бы ничего не делать. Но что если это ломает логику программы? В таком случае правльнее бросить NullPointerException и пускай сверху с ним разберуться. То есть с ошибкой мы неможем разобраться прямо в месте её возникновения, т.к. мы не знаем как наш метод используется. В методах вызывающих наш мы сможем обработать ошибку, т.к. обладаем достаточным контекстом ошибки. 

Пример конечно надуманный null почти всегда можно обработать в коде без всяких исключений.

#Создание исключений

Чтобы вызвать исключение нам сначало необходимо создать объект-исключение. Он создаётся точно также как и другие объекты в куче с помощью оператора **new**. У всех стандартных исключений существует как минимум два конструктора: без аргументов и с аргументом строкой: объясняет причину исключения.

Далее нам потребуется непосредственно передать исключение системе обработки: это осуществляется с помощью ключевого слова **throw**.

```java
Exception e = new NullPointerException("list = null; can't shuffle");
throw e; //здесь дальнейшее исполнение метода прерывается
```
Чаще всего исключение создаётся в том же месте в котором и пробрасывается:
```java
throw new NullPointerException("list = null; can't shuffle");
```

Во время вызова исключения происходит *безусловный переход* что-то вроде **return**, но при этом метод не возвращает то значение, которое предусмотрено (по сути он никакого значения не возвращает).

Начиная со слова `throw` появляется некоторая магия вокруг исключений: в качестве аргумента для `throw` мы передаём объект, но не каждый объект может стать претендентом на роль исключения. Чтобы объект можно было *пробросить* он (его класс) должен наследовать класс **Throwable** (странно что не интерфейс). Почему это называют магией? Потому что это как-то *не по правилам* чтоли. Если ключевое слово принимает объект, то наверное любой объект. Дальше будет ещё больше магии.


#Перехват исключений: Конструкция try catch

Ранее уже упоминалось, что при пробросе исключения система ищет подходящий обработчик. Исключения обрабатывает блок **try**

```java
try{
    dangerous1();
    dangerous2();
    dangerous3();
}
```
Точнее сказать он их не обрабатывает а перехватывает. То есть если в одном из выражений (не обязательно методов это может быть и просто `1/0;`)  возникнет исключение, то оно перейдёт к обработчик. Просто так блок `try` не пишется за ним обязательно должен следовать `catch` либо `finally`, либо оба сразу.

##catch

```java
private static void dangerous(){
		throw new RuntimeException();
}

public static void main(String[] args){
	try{
		dangerous();
	}
	catch (Exception e){
		e.printStackTrace();
	}
}

>>  java.lang.RuntimeException
	at com.company.Main.dangerous(Main.java:158)
	at com.company.Main.main(Main.java:163)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:601)
	at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)
```
Если бы мы не обработали это исключение нас бы ожидал примерно такой же вывод. Зато теперь обработав исключение мы можем работать дальше. Зачастую в случае ловли исключения у нас не остаётся вариантов как продолжать работать. Иногда можно уведомить пользователя например о том что не удаётся открыть файл, мол выбери другой.

Ключевое слово **catch** предназначено для того, чтобы поймать и обработать исключение. `catch` в качестве аргумента принимает также `Throwable` и использует его как аргумент функции. Если никакого исключения не было то блок `catch` не вызовется. Сходство `catch` с функцией в том что к нему будет применен полиморфизм.

Во-первых в этом примере вы можете заметить восходящее преобразование: от RuntimeException до Exception (оба потомки Throwable). Exception является предком для RuntimeException - поэтому преобразование допустимо.

Во-вторых допустимо несколько веток для `catch` (допустим Throwable1 и 2 и 3 унаследованы от Throwable):

```java
try{
    throw new Throwable1();
    throw new Throwable2();
    throw new Throwable3();
}
catch(Throwable3 t){}//допустимо несколько (включая 0) блоков catch
catch(Throwable2 t){}
catch(Throwable1 t){} // <- вызовется этот
```

Что тут происходит? Сначала пробрасывается исключение типа `Throwable1`. Значит остальное исполнение блока `try` прекращается и начинается поиск подходящего обработчика. Cначала находим обработчик для `Throwable3`, но 1 и 3 находятся на разных ветках наследования, поэтому восходящее преобразование недопустимо. Далее ищем другой обработчик - 2 тоже не подходит. и останавливаемся на 3. 

Что будет если убрать строку `catch(Throwable1 t){}`? Обработчик так и не будет найден и исключение проброситься на уровень выше. Возможно во всей программе не будет обработчика тогда программа приостановится.

Что будет если добавить строку `catch(Throwable t){}`? Если мы её добавим в конце то всё относительно хорошо:
```java
try{
    //опасный код
}
catch(Throwable3 t){}
catch(Throwable2 t){}
catch(Throwable1 t){} 
catch(Throwable t){}
```
В итоге возможно 3й 2й или 1й обработчики в зависимости от бросаемого исключения. И если бросается какое-то другое исключение то обязательно исполнится последний обработчик. Если мы поставим его в начало:
```java
try{
    //опасный код
}
catch(Throwable t){}
catch(Throwable3 t){}
catch(Throwable2 t){}
catch(Throwable1 t){} 
```
 То исполнится только первый обработчик. То есть остальные 3 ниже **никогда** не исполнятся. Ваша IDE их вам скорее всего подчеркнет, т.к. они бесполезны. Это происходит потому что поиск подходящего обработчика осуществляется последовательно сверху вниз. А `Throwable` является наиболее общим типом для всех исключений.

##Оператор instanceof

Вас возможно задело то что во время исполнения `catch` может проверить, к какому типу относится объект. Такую магию можно провернуть и в остальном коде не относящемся к исключениям. 

Дело в том что информация о классе объекта, о всей иерархии классов хранится в памяти во время исполнения (в отличии от например от C++ где с этим посложнее). И более того вся эта информация может бывть предоставлена программисту (гуглите reflection).

В более менее простом случае, когда мы откуда то получаем ссылку общего типа и нам необходимо узнать частный то мы можем воспользоваться оператором `instanceof`. По сути `instanceof` является таким же бинарным булевым оператором как и `==` или `<=` и т.д. Только слева он принимает объект, а справа класс. Ну и соответственно проверяет есть ли класс в списке предков класса данного объекта. Важно, что он делает это не на основании информации о типе переменной (иначе бы это можно было вычислить на этапе компиляции), а во время исполнении просматривает реальный класс объекта.

```java
Throwable t = new RuntimeException();
//...
if(t instanceof Exception){ //true
	Exception e = (Exception)t; // выполняем небезопасное преобразование, 
	//но для себя можем быть уверены, что оно не вызовет ошибок
	//...
}
if(t instanceof Error){ //false
	Error e = (Error)t;
	//...
}
if(t instanceof Object){ //всегда истина за исключением тех случаев когда t = null
	//для null instanceof всегда возращает false
}
```

##Пример

Небольшой пример использования `try catch`. Допустим у нас имеется `Map<String, Map<String, List<String>>>`. Выглядит безумно, но можно допустить, что мы парсим какой-нибудь структурированый текстовый формат (например json или xml) в мапы и списки. Конечно сейчас есть библиотеки, чтобы парсить более типобезопасно.

Итак в нашем файле (или не файле) допустим хранится информация посылаемая от клиента к серверу - запрос к ячейкам базы данных, слова для поиска. Мы почти уверены, что там есть поле "request" и поле "keywords" и в нем интересующая нас информация. Правда есть все же вероятность, что текст немного поврежден. Или клиент балуется и пытается послать что-нибудь другое. 

```java
//псевдокод конечно же
try{
	Map<String, Map<String, List<String>>> req = (Map<String, Map<String, List<String>>>)client.parseRequest();//ошибка преобразования
	for(String keyword: req.get("request").get("keywords")){ //3 NullPointerException
		//TODO
	}
}catch(RuntimeException e){
	Log.warning("it's impossible but wrong request: " + client.getRequest());
	// а ещё здесь мы должны послать клиенту ответ, что запрос неверный
}
```

Иногда это удобно - сделать обработчик всех критических ситуаций в одном месте. Правда это в то же время пример плохого кода, т.к. почти всегда потомков RuntimeException можно отловить вполне стандартными средствами. То есть RuntimeException это например деление на 0, обращение к null, выход за границы массива, ошибка преобразования. Почти всегда такие ошибки можно отловить if. И в этом плане `try catch` представляется нам синтаксическим сахаром, который освобождает нас от необходимости нагромождать `if`.

Почему все же не стоит здесь пользоваться `try catch`? Дело в том что проброс исключения - операция весьма **дорогостоящая**. Ввиду того, что необходимо сохранить весь стек вызовов и состояние программы на момент исключения. Иногда это не столь критично, зачастую ясность кода важнее производительности (т.к. поддержка кода может обойтись дороже чем железо) и может быть такое, что нам нужны гарантии от определенного участка кода. 

##Checked и Unchecked Exceptions

Начнём паралельно знакомиться с java.io.

io - обозначет input/output (ввод/вывод). Предоставляет базовые средства для общения с внешним миром. `System.out` также относится к io (точнее использует его). Самое обыденный пример ввода/вывода это работа с файлами. А самая простая обработка файла это побайтовое чтение и побайтовая запись. Дальше мы можем обернуть эти байты в более высококоуровневые конструкции (что и сделано в других классах в java.io). Напишем (лучше в IDE) следующую строку:

```java
import java.io.FileInputStream;
//... main
FileInputStream in = new FileInputStream("input.txt");
```
На первый взгляд всё выглядит достаточно безобидно. У класса `FileInputStream` есть конструктор принимающий строку (кстати если вы оставите текстовый курсор на конструкторе и нажмете `CTRL+B` в IDEA то перейдете к опеределению конструктора и увидете предупреждение `throws FileNotFoundException` в коде - вернемся к этому позже). Создаём объект и присваиваем переменной подходящего типа. Казалось бы всё в порядке, но при компиляции (ну или в IDE ещё до компиляции) видим ошибку: `java: unreported exception java.io.FileNotFoundException; must be caught or declared to be thrown`.

До этого ранее вы встречались с исключениями, которые обсуждались выше. Забыли проинициализировать переменную и все такое. Но все эти исключения (скорее всего) были потомками `RuntimeException`. Такие исключения называются **unchecked**. Это нигде не отражено в коде разделение на checked/unchecked является магией (то есть просто знать надо). Unchecked (непроверяемые) исключения заключаются в том что мы не обязаны их обрабатывать. Такое иссключение вполне естественно. Более странными выглядят **checked** исключения с которыми вы ранее не сталкивались. Их мы обязаны проверять (всмысле обрабатывать). 
